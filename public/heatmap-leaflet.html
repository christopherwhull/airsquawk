<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>AirSquawk</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/esri-leaflet@3.0.10/dist/esri-leaflet.js"></script>
    <style>
        :root {
            --bg: #0f0f10;
            --panel-bg: #121213;
            --card-bg: #1b1b1b;
            --text: #e0e0e0;
            --muted: #bbb;
            --accent: #0066cc;
            --highlight: #00ff99;
        }

        /* Apply dark backgrounds to all non-map UI areas by default */
        body {
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
        }

        /* Keep the map area visually separate; #map has its own background rule already */
        .header {
            background: var(--panel-bg);
            padding: 12px 16px;
            border-bottom: 1px solid #222;
        }

        .controls {
            background: transparent;
            padding: 8px 16px 16px 16px;
        }

        .info-panel {
            background: transparent;
            color: var(--text);
        }

        .legend { background: rgba(18,18,18,0.95); color: var(--text); }
        .info-card { background: var(--card-bg); color: var(--text); border-left-color: var(--accent); }
        select, input { background: #141414; color: var(--text); border-color: #2b2b2b }
        .error { background: #b71c1c }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Map container must have an explicit height for Leaflet to render */
        #map {
            width: 100%;
            height: calc(100vh - 340px);
            min-height: 360px;
            background: #111;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            font-weight: 500;
            color: #bbb;
            min-width: 100px;
        }

        select, input {
            padding: 6px 10px;
            background: #1e1e1e;
            color: #e0e0e0;
            border: 1px solid #444;
            border-radius: 4px;
            font-size: 14px;
        }

        button {
            padding: 6px 15px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        button:hover {
            background: #0052a3;
        }

        button:active {
            transform: scale(0.98);
        }

        .info-panel {
            padding: 15px;
            background: #2a2a2a;
            border-top: 1px solid #333;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .info-card {
            background: #1e1e1e;
            padding: 12px;
            border-radius: 4px;
            border-left: 3px solid #0066cc;
        }

        .status-ok { color: #76c776; }
        .status-loading { color: #ffd166; }
        .status-error { color: #ff6b6b; }

        .info-card strong {
            display: block;
            color: #0066cc;
            margin-bottom: 5px;
        }

        .info-card span {
            font-size: 14px;
            color: #bbb;
        }

        .loading {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            z-index: 1000;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            z-index: 400;
            max-width: 300px;
            font-size: 12px;
            color: #333;
        }

        .legend h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
        }

        .error {
            background: #c62828;
            color: white;
            padding: 15px;
            border-radius: 4px;
            margin: 10px;
            display: none;
        }

        .error.show {
            display: block;
        }
    </style>
</head>
<body>
    <div class="header">
        <header style="text-align: center; margin-bottom: 20px;">
            <img src="/media/airsquak.jpg" alt="AirSquawk Logo" style="max-width: 300px; height: auto;">
            <h1>AirSquawk</h1>
        </header>

        <div class="controls">
            <div class="control-group">
                <label for="time-window">Time Window:</label>
                <select id="time-window">
                    <option value="1h">1 Hour</option>
                    <option value="4h">4 Hours</option>
                    <option value="12h">12 Hours</option>
                    <option value="24h" selected>24 Hours</option>
                    <option value="7d">7 Days</option>
                    <option value="all">All Time</option>
                </select>
            </div>

            <div class="control-group">
                <label for="color-mode">Color:</label>
                <select id="color-mode">
                    <option value="intensity" selected>Intensity</option>
                    <option value="density">Density Gradient</option>
                    <option value="altitude">Altitude-based</option>
                </select>
            </div>

            <div class="control-group">
                <label for="scaling-mode">Scaling:</label>
                <select id="scaling-mode">
                    <option value="linear">Linear</option>
                    <option value="log" selected>Logarithmic</option>
                    <option value="sqrt">Square Root</option>
                    <option value="power">Power (Œ≥=2.2)</option>
                </select>
            </div>

            <div class="control-group">
                <label for="opacity">Opacity:</label>
                <input type="range" id="opacity" min="0.1" max="1.0" step="0.1" value="0.7" style="width: 100px;">
                <span id="opacity-value">0.7</span>
            </div>

            <div class="control-group">
                <label for="show-borders">
                    <input type="checkbox" id="show-borders"> Show Borders
                </label>
            </div>

            <div class="control-group">
                <label for="show-live">
                    <input type="checkbox" id="show-live"> Show Live Positions
                </label>
            </div>

            <div class="control-group">
                <label for="use-external-squawk">
                    <input type="checkbox" id="use-external-squawk"> Use External Squawk API
                </label>
            </div>

            <div class="control-group" style="min-width:260px;">
                <label for="squawk-api-base">Squawk API Base:</label>
                <input id="squawk-api-base" type="text" placeholder="https://squawk.example/api" style="width:220px;">
            </div>

            <div class="control-group">
                <label for="track-window-input">Track Window (min):</label>
                <input id="track-window-input" type="number" min="1" max="1440" step="1" value="10" style="width:70px;">
            </div>

            <div class="control-group">
                <label for="show-long-tracks">
                    <input type="checkbox" id="show-long-tracks"> Show Long Tracks
                </label>
            </div>

            <div class="control-group">
                <label for="persist-on-click">
                    <input type="checkbox" id="persist-on-click"> Persist track on click
                </label>
            </div>

            <div class="control-group">
                <label for="dark-mode">
                    <input type="checkbox" id="dark-mode"> Dark Mode
                </label>
            </div>

            <div class="control-group">
                <button id="clear-persistent-tracks" onclick="clearAllPersistentTracks()">Clear Tracks</button>
            </div>

            <div class="control-group">
                <button id="toggle-persistent-visibility" onclick="togglePersistentVisibility()">Hide Persisted Tracks</button>
            </div>

            <div class="control-group">
                <button id="toggle-debug-dump" onclick="toggleDebugDump()">Show Debug Dump</button>
            </div>

            <button onclick="loadGridData()">üîÑ Refresh</button>
            <button onclick="toggleLegend()">üìã Legend</button>
            <button onclick="resetMap()">üè† Reset View</button>
        </div>

        <div id="error" class="error"></div>
        
        <div style="background: rgba(18,18,18,0.8); color: #bbb; padding: 8px 16px; font-size: 12px; border-bottom: 1px solid #333;">
            <strong>FAA Aviation Charts:</strong> Charts only cover specific geographic areas (primarily US airspace). Areas outside coverage will appear blank. Zoom to 7-12x for best results.
        </div>
    </div>

    <div id="map"></div>

    <div class="info-panel">
        <div class="info-card">
            <strong>Grid Cells</strong>
            <span id="cell-count">Loading...</span>
        </div>
        <div class="info-card">
            <strong>Total Positions</strong>
            <span id="point-count">Loading...</span>
        </div>
        <div class="info-card">
            <strong>Load Time</strong>
            <span id="load-time">Loading...</span>
        </div>
        <div class="info-card">
            <strong>Max Density</strong>
            <span id="max-density">Loading...</span>
        </div>
        <div class="info-card">
            <strong>Coverage Area</strong>
            <span id="coverage-area">Loading...</span>
        </div>
        <div class="info-card">
            <strong>Live Fetch</strong>
            <span id="live-fetch-status" class="status-loading">idle</span>
        </div>
        <div class="info-card">
            <strong>Track Fetch</strong>
            <span id="track-fetch-status">idle</span>
        </div>
        <div class="info-card">
            <strong>Persisted Tracks</strong>
            <span id="persisted-tracks-indicator">0</span>
            <div id="persisted-tracks-list" style="margin-top:6px;font-size:12px;color:#bbb;max-height:72px;overflow:auto"></div>
        </div>
        <div class="info-card" id="debug-card">
            <strong>Debug</strong>
            <span id="debug-panel" style="font-size:12px;color:#bbb;display:block;max-height:72px;overflow:auto">No hex selected</span>
        </div>
    </div>

    <div id="loading" class="loading">
        <div class="spinner"></div>
        <p>Loading grid data...</p>
    </div>

    <div id="legend" class="legend" style="display: none;">
        <h4>Position Density</h4>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(0, 0, 255, 0.3);"></div>
            <span>Low (1-10)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(0, 255, 0, 0.5);"></div>
            <span>Medium (11-50)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(255, 255, 0, 0.7);"></div>
            <span>High (51-200)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(255, 0, 0, 0.8);"></div>
            <span>Very High (200+)</span>
        </div>
    </div>

    <script>
        // Initialize map centered on Great Lakes region where FAA sectional charts are available
        const map = L.map('map').setView([42.0, -87.9], 7); // Center on Chicago/Great Lakes

        // Create dedicated panes for live markers and persistent tracks so they sit above grid layers
        map.createPane('livePane');
        map.getPane('livePane').style.zIndex = 650; // above overlay tiles
        map.createPane('persistentPane');
        map.getPane('persistentPane').style.zIndex = 660; // above livePane
        // Dedicated pane for heatmap/grid so it stays below live markers
        map.createPane('heatmapPane');
        map.getPane('heatmapPane').style.zIndex = 400; // below livePane/persistentPane

        // Add OpenStreetMap base layer
        const osmLayer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 18
        });

        // Add OpenTopoMap for terrain visualization
        const openTopoLayer = L.tileLayer('https://tile.opentopomap.org/{z}/{x}/{y}.png', {
            attribution: 'Map data: ¬© OpenStreetMap contributors, SRTM | Map style: ¬© OpenTopoMap (CC-BY-SA)',
            maxZoom: 17
        });

        // Add CartoDB Voyager (good for aviation - clean, labels airports)
        const cartoVoyagerLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
            attribution: '¬© OpenStreetMap contributors ¬© CARTO',
            maxZoom: 19,
            subdomains: 'abcd'
        });

        // FAA aviation chart layers from local tile proxy
        const proxyBase = 'http://localhost:3004/tile';

        // Official FAA VFR Terminal Area Chart
        const faaVfrTerminal = L.tileLayer(`${proxyBase}/vfr-terminal/{z}/{x}/{y}`, {
            attribution: '¬© FAA',
            maxZoom: 12,
            minZoom: 7,
            zIndex: 200,
            opacity: 0.8,
            errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==' // transparent 1x1 pixel
        });

        // Official FAA VFR Sectional Chart
        const faaVfrSectional = L.tileLayer(`${proxyBase}/vfr-sectional/{z}/{x}/{y}`, {
            attribution: '¬© FAA',
            maxZoom: 12,
            minZoom: 7,
            zIndex: 200,
            opacity: 0.8,
            errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==' // transparent 1x1 pixel
        });

        // Official FAA IFR Area Low Chart
        const faaIfrAreaLow = L.tileLayer(`${proxyBase}/ifr-arealow/{z}/{x}/{y}`, {
            attribution: '¬© FAA',
            maxZoom: 12,
            minZoom: 7,
            zIndex: 200,
            opacity: 0.8,
            errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==' // transparent 1x1 pixel
        });

        // Official FAA IFR Enroute High Chart
        const faaIfrHigh = L.tileLayer(`${proxyBase}/ifr-enroute-high/{z}/{x}/{y}`, {
            attribution: '¬© FAA',
            maxZoom: 12,
            minZoom: 7,
            zIndex: 200,
            opacity: 0.8,
            errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==' // transparent 1x1 pixel
        });

        // ArcGIS base map layers
        const arcgisImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
            maxZoom: 18
        });

        const arcgisStreet = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, NAVTEQ, USGS, Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012',
            maxZoom: 18
        });

        const arcgisTopo = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community',
            maxZoom: 18
        });

        // Layer control
        const baseLayers = {
            "OpenStreetMap (Internet)": osmLayer,
            "CartoDB Voyager (Internet)": cartoVoyagerLayer,
            "OpenTopoMap (Internet)": openTopoLayer,
            "ArcGIS World Imagery": arcgisImagery,
            "ArcGIS World Street Map": arcgisStreet,
            "ArcGIS World Topo": arcgisTopo
        };
        
        const overlayLayers = {
            "FAA VFR Terminal": faaVfrTerminal,
            "FAA VFR Sectional": faaVfrSectional,
            "FAA IFR Area Low": faaIfrAreaLow,
            "FAA IFR Enroute High": faaIfrHigh
        };
        
        osmLayer.addTo(map);
        // Keep a handle to the layers control so we can add overlays once created
        const layersControl = L.control.layers(baseLayers, overlayLayers).addTo(map);
        
        // Log when map zoom changes
        map.on('zoomend', () => {
            // Future zoom-based logic can go here
        });

        let gridLayer = null;
        // we'll register overlays (heatmap grid, live positions, persisted tracks) with the layers control
        let currentData = null;

        // Cookie management functions
        function setCookie(name, value, days = 365) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            document.cookie = `${name}=${value};expires=${date.toUTCString()};path=/`;
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        function saveSettings() {
            const settings = {
                timeWindow: document.getElementById('time-window').value,
                colorMode: document.getElementById('color-mode').value,
                scalingMode: document.getElementById('scaling-mode').value,
                opacity: document.getElementById('opacity').value,
                showBorders: document.getElementById('show-borders').checked
                , showLive: document.getElementById('show-live').checked
                , trackWindowMinutes: document.getElementById('track-window-input') ? document.getElementById('track-window-input').value : '1'
                , persistOnClick: document.getElementById('persist-on-click') ? document.getElementById('persist-on-click').checked : false
                , darkMode: document.getElementById('dark-mode') ? document.getElementById('dark-mode').checked : false
                , useExternalSquawk: document.getElementById('use-external-squawk') ? document.getElementById('use-external-squawk').checked : false
                , squawkApiBase: document.getElementById('squawk-api-base') ? document.getElementById('squawk-api-base').value : ''
            };
            setCookie('leafletHeatmapSettings', JSON.stringify(settings));
        }

        function loadSettings() {
            const saved = getCookie('leafletHeatmapSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    if (settings.timeWindow) document.getElementById('time-window').value = settings.timeWindow;
                    if (settings.colorMode) document.getElementById('color-mode').value = settings.colorMode;
                    if (settings.scalingMode) document.getElementById('scaling-mode').value = settings.scalingMode;
                    if (settings.opacity) {
                        document.getElementById('opacity').value = settings.opacity;
                        document.getElementById('opacity-value').textContent = settings.opacity;
                    }
                    if (settings.showBorders !== undefined) document.getElementById('show-borders').checked = settings.showBorders;
                    if (settings.showLive !== undefined) document.getElementById('show-live').checked = settings.showLive;
                    if (settings.trackWindowMinutes !== undefined && document.getElementById('track-window-input')) {
                        document.getElementById('track-window-input').value = settings.trackWindowMinutes;
                    }
                    if (settings.persistOnClick !== undefined && document.getElementById('persist-on-click')) {
                        document.getElementById('persist-on-click').checked = settings.persistOnClick;
                    }
                    if (settings.useExternalSquawk !== undefined && document.getElementById('use-external-squawk')) {
                        document.getElementById('use-external-squawk').checked = settings.useExternalSquawk;
                    }
                    if (settings.squawkApiBase !== undefined && document.getElementById('squawk-api-base')) {
                        document.getElementById('squawk-api-base').value = settings.squawkApiBase;
                    }
                    if (settings.darkMode !== undefined && document.getElementById('dark-mode')) {
                        document.getElementById('dark-mode').checked = settings.darkMode;
                        try { if (settings.darkMode) document.body.classList.add('dark-mode'); else document.body.classList.remove('dark-mode'); } catch (e) {}
                    }
                } catch (e) {
                    console.error('!!! CRITICAL ERROR loading settings:', e);
                }
            } else {
                // Set default scaling to logarithmic if no saved settings
                document.getElementById('scaling-mode').value = 'log';
            }
        }

        // Load settings on page load
        loadSettings();

        

        // If saved settings requested live updates, start them now
        try {
            const showLiveElem = document.getElementById('show-live');
            if (showLiveElem && showLiveElem.checked) {
                // Defer starting live positions until after initialization to avoid TDZ issues
                setTimeout(() => { try { toggleLivePositions(); } catch (e) { console.warn('Auto-start toggle failed', e); } }, 50);
            }
        } catch (e) {
            console.warn('Failed to auto-start live positions:', e);
        }

        // Update opacity display
        document.getElementById('opacity').addEventListener('input', (e) => {
            document.getElementById('opacity-value').textContent = e.target.value;
            saveSettings();
            if (currentData) updateGridDisplay();
        });

        document.getElementById('color-mode').addEventListener('change', () => {
            saveSettings();
            if (currentData) updateGridDisplay();
        });

        document.getElementById('show-borders').addEventListener('change', () => {
            saveSettings();
            if (currentData) updateGridDisplay();
        });

        document.getElementById('scaling-mode').addEventListener('change', () => {
            saveSettings();
            if (currentData) updateGridDisplay();
        });

        document.getElementById('time-window').addEventListener('change', () => {
            saveSettings();
            loadGridData();
        });

        // Live positions toggle
        document.getElementById('show-live').addEventListener('change', () => {
            saveSettings();
            toggleLivePositions();
        });

        // External squawk API controls
        const useExternalSquawkElem = document.getElementById('use-external-squawk');
        if (useExternalSquawkElem) {
            useExternalSquawkElem.addEventListener('change', () => {
                saveSettings();
            });
        }
        const squawkApiBaseElem = document.getElementById('squawk-api-base');
        if (squawkApiBaseElem) {
            squawkApiBaseElem.addEventListener('change', () => {
                saveSettings();
            });
        }

        // Show long tracks toggle
        const longTracksCheckbox = document.getElementById('show-long-tracks');
        if (longTracksCheckbox) {
            longTracksCheckbox.addEventListener('change', () => {
                saveSettings();
                try {
                    if (longTracksCheckbox.checked) {
                        startLongTracksPolling();
                    } else {
                        stopLongTracksPolling();
                    }
                } catch (e) { console.warn('Long tracks toggle failed', e); }
            });
        }

        // Dark mode toggle
        const darkModeCheckbox = document.getElementById('dark-mode');
        if (darkModeCheckbox) {
            darkModeCheckbox.addEventListener('change', () => {
                try {
                    if (darkModeCheckbox.checked) document.body.classList.add('dark-mode');
                    else document.body.classList.remove('dark-mode');
                    saveSettings();
                } catch (e) { console.warn('Dark mode toggle failed', e); }
            });
        }

        // Persist-on-click toggle
        const persistCheckbox = document.getElementById('persist-on-click');
        if (persistCheckbox) {
            persistCheckbox.addEventListener('change', () => {
                saveSettings();
            });
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
            setTimeout(() => errorDiv.classList.remove('show'), 5000);
        }

        function showLoading(show) {
            document.getElementById('loading').classList.toggle('active', show);
        }

        // Live positions support
        let liveLayer = L.layerGroup();
        let liveIntervalId = null;
        // Map of current live markers for smooth updates (hex -> L.marker)
        const liveMarkers = new Map();
        // Map of last seen squawk per hex (hex -> '1234' or null)
        const lastSquawk = new Map();
        // Map of short trail polylines showing recent positions (hex -> L.Polyline)
        const liveTrails = new Map();
        // Keep the last N valid positions per hex so we can draw a small tail (hex -> Array<[lat,lon]>)
        const lastPositions = new Map();
        const LAST_POSITIONS_COUNT = 3;
        // Hover debounce timers to reduce rapid fetch/redraw
        let hoverFetchTimer = null;
        let hoverClearTimer = null;
        const HOVER_DEBOUNCE_MS = 150; // delay before fetching track on hover
        const HOVER_CLEAR_MS = 200; // delay before clearing hover track on mouseout
        // Map of flight poller intervals (hex -> intervalId) used to poll /api/flight every second
        const flightPollers = new Map();
        // Batch flight cache (icao -> { ts, data }) to avoid excessive UI updates
        const BATCH_FLIGHT_TTL = 5000; // 5s
        const flightsCache = new Map();
        // Squawk cache (hex -> { ts, squawk })
        const BATCH_SQUAWK_TTL = 5000; // 5s
        const squawkCache = new Map();
        // Batch polling controls
        let batchPollIntervalId = null;
        const BATCH_POLL_INTERVAL_MS = 5000; // default 5s between batch polls
        const BATCH_MAX_PER_REQUEST = 50; // max items per batch request
        let batchPollInFlight = false;
        // Cache aircraft info fetched from server (/api/aircraft/:icao24)
        const aircraftInfoCache = new Map(); // hex -> { ts, data }
        const AIRCRAFT_CACHE_TTL = 60 * 1000; // 60s
        // Airline name to code mapping for logo lookup
        const airlineNameToCode = new Map(); // name -> code
        // Vertical rate tracking for color coding aircraft
        const verticalRateCache = new Map(); // hex -> { altitude, timestamp, verticalRate }

        async function fetchAircraftInfo(hex) {
            if (!hex) return null;
            const key = hex.toLowerCase();
            const cached = aircraftInfoCache.get(key);
            if (cached && (Date.now() - cached.ts) < AIRCRAFT_CACHE_TTL) return cached.data;
            try {
                const res = await fetch(`/api/aircraft/${encodeURIComponent(key)}`);
                if (!res.ok) return null;
                const data = await res.json();
                aircraftInfoCache.set(key, { ts: Date.now(), data });
                return data;
            } catch (e) {
                return null;
            }
        }

        // Load airline name-to-code mapping for logo lookup
        async function loadAirlineMapping() {
            try {
                const res = await fetch('/api/airlines');
                if (!res.ok) return;
                const airlines = await res.json();
                // Populate the mapping: name -> code
                for (const [code, info] of Object.entries(airlines)) {
                    if (info && info.name) {
                        airlineNameToCode.set(info.name.toLowerCase(), code);
                    }
                }
                console.log(`Loaded ${airlineNameToCode.size} airline name-to-code mappings`);
            } catch (e) {
                console.error('Failed to load airline mapping:', e);
            }
        }

        // Layer used to draw a hovered aircraft track (temporary)
        let trackLayer = L.layerGroup();
        let hoverTrackHex = null;

        // Long tracks layer (drawn from /api/track for visible hexes when enabled)
        let longTracksLayer = L.layerGroup();
        let longTracksIntervalId = null;
        const LONG_TRACKS_POLL_MS = 15000; // fetch long tracks every 15s when enabled
        const LONG_TRACKS_BATCH_SIZE = 8; // chunk size for parallel requests

        // Live tracks layer: short recent tracks for currently active flights
        let liveTracksLayer = L.layerGroup();
        let liveTracksIntervalId = null;
        const LIVE_TRACKS_POLL_MS = 7000; // refresh live tracks every 7s

        // Persistent tracks shown when user clicks with "Persist track on click" enabled
        const persistentTracksLayer = L.layerGroup();
        persistentTracksLayer.addTo(map);
        const persistentTracks = new Map(); // hex -> LayerGroup
        // Temporary on-click tracks (shown when persist-on-click is NOT enabled)
        const tempPersistentLayer = L.layerGroup();
        const TEMP_PERSIST_MS = 20 * 1000; // 20 seconds for temporary click tracks
        // Initialize persisted indicator (safe now that persistentTracks exists)
        if (typeof updatePersistedIndicator === 'function') updatePersistedIndicator();

        // Client-side short TTL cache for per-hex track fetches to avoid repeated calls
        const TRACK_CACHE_TTL_MS = 8000; // 8 seconds
        const trackCache = new Map(); // key -> { ts, data }
        const trackFetchPromises = new Map(); // key -> Promise

        // Helper to determine which squawk API base to use. If an external squawk API is enabled
        // via the UI, use that base; otherwise default to the local `/api` base.
        function getSquawkApiBase() {
            try {
                const useExternal = document.getElementById('use-external-squawk') && document.getElementById('use-external-squawk').checked;
                if (useExternal) {
                    const v = (document.getElementById('squawk-api-base') ? document.getElementById('squawk-api-base').value : '').trim();
                    if (v) return v;
                }
            } catch (e) {}
            return '/api';
        }

        // Start polling the lightweight flights endpoint for a single aircraft (1 Hz)
        function startFlightPolling(hex, positionObj) {
            if (!hex) return;
            const key = hex.toLowerCase();
            if (flightPollers.has(key)) return; // already polling

            async function pollOnce() {
                try {
                    const res = await fetch(`/api/flight?icao=${encodeURIComponent(key)}`);
                    if (!res.ok) return;
                    const payload = await res.json();
                    const fl = payload && payload.flight;
                    if (!fl) return;
                    // Merge dynamic flight fields into the live position object used for tooltip/popups
                    try {
                        mergePreferExisting(positionObj, fl);
                        // Ensure squawk/transponder fields are normalized and stored under both names
                        try {
                            const v = fl.sqk || fl.squawk || fl.transponder || fl.transponder_code || fl.squawk_code || null;
                            if (v) {
                                positionObj.sqk = v;
                                positionObj.squawk = positionObj.squawk || v;
                                lastSquawk.set(key, v);
                            }
                        } catch (e) {}
                    } catch (e) {}
                    // Update marker tooltip/popup if marker exists
                    const marker = liveMarkers.get(key);
                    if (marker) {
                        const html = buildHoverTooltipHTML(positionObj);
                        try { const tt = marker.getTooltip && marker.getTooltip(); if (tt && tt.setContent) tt.setContent(html); }
                        catch (e) {}
                        try { const pp = marker.getPopup && marker.getPopup(); if (pp && pp.setContent) pp.setContent(html); } catch (e) {}
                    }
                } catch (err) {
                    // silent
                }
            }

            // Initial immediate poll, then every 1s
            pollOnce();
            const id = setInterval(pollOnce, 1000);
            flightPollers.set(key, id);
        }

        function stopFlightPolling(hex) {
            if (!hex) return;
            const key = hex.toLowerCase();
            const id = flightPollers.get(key);
            if (id) {
                clearInterval(id);
                flightPollers.delete(key);
            }
        }

        // POST /api/flights/batch helper
        async function fetchFlightsBatch(icaoList) {
            if (!Array.isArray(icaoList) || icaoList.length === 0) return {};
            try {
                const res = await fetch('/api/flights/batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ icao24: icaoList })
                });
                if (!res.ok) throw new Error(`Batch flights ${res.status}`);
                const payload = await res.json();
                return payload.results || {};
            } catch (err) {
                console.warn('Batch flights fetch failed', err);
                return {};
            }
        }

        // Fetch squawk for a list of hexes (uses GET /api/squawk?hex=...) and returns map { hex: squawk }
        async function fetchSquawksFor(hexList) {
            const result = {};
            if (!Array.isArray(hexList) || hexList.length === 0) return result;
            // Check cache first
            const toFetch = [];
            hexList.forEach(h => {
                const lk = (h || '').toString().toLowerCase();
                const cached = squawkCache.get(lk);
                if (cached && (Date.now() - cached.ts) < BATCH_SQUAWK_TTL) {
                    result[lk] = cached.squawk;
                } else {
                    toFetch.push(lk);
                }
            });
            // Fetch missing squawks in parallel (small numbers)
            // Determine API base: allow optional external API configured in UI
            const apiBase = getSquawkApiBase();
            const promises = toFetch.map(async (lk) => {
                try {
                    const url = `${apiBase.replace(/\/$/, '')}/squawk?hex=${encodeURIComponent(lk)}`;
                    const res = await fetch(url);
                    if (!res.ok) return null;
                    const payload = await res.json();
                    const sq = payload && (payload.squawk || payload.sqk || null);
                    squawkCache.set(lk, { ts: Date.now(), squawk: sq });
                    result[lk] = sq;
                } catch (e) {
                    // don't fail entire batch
                    squawkCache.set(lk, { ts: Date.now(), squawk: null });
                    result[lk] = null;
                }
            });
            await Promise.all(promises);
            return result;
        }

        // Fetch a single squawk value, retrying for up to `timeoutMs` (default 1000ms) at `intervalMs` (default 200ms).
        // Returns the squawk string or null if none available within timeout. Updates squawkCache.
        async function fetchSquawkWithWait(hex, timeoutMs = 1000, intervalMs = 200) {
            if (!hex) return null;
            const lk = hex.toString().toLowerCase();
            // check cache first
            const cached = squawkCache.get(lk);
            if (cached && (Date.now() - cached.ts) < BATCH_SQUAWK_TTL) return cached.squawk;

            const start = Date.now();
            while ((Date.now() - start) < timeoutMs) {
                try {
                    const apiBase = getSquawkApiBase();
                    const res = await fetch(`${apiBase.replace(/\/$/, '')}/squawk?hex=${encodeURIComponent(lk)}`);
                    if (res && res.ok) {
                        try {
                            const payload = await res.json();
                            const sq = payload && (payload.squawk || payload.sqk || null);
                            squawkCache.set(lk, { ts: Date.now(), squawk: sq });
                            if (sq) {
                                lastSquawk.set(lk, sq);
                                return sq;
                            }
                        } catch (e) {
                            squawkCache.set(lk, { ts: Date.now(), squawk: null });
                        }
                    }
                } catch (e) {
                    // ignore transient network errors
                }
                // wait before retrying
                await new Promise(r => setTimeout(r, intervalMs));
            }
            // final attempt: return whatever is in cache (could be null)
            const final = squawkCache.get(lk);
            return final ? final.squawk : null;
        }

        

        // Start/stop periodic batch polling of visible aircraft (merges results into tooltips)
        function startBatchPollingVisibleFlights() {
            if (batchPollIntervalId) return;
            // initial run then interval
            runBatchPollOnce();
            batchPollIntervalId = setInterval(runBatchPollOnce, BATCH_POLL_INTERVAL_MS);
        }

        // Start/stop long tracks fetch
        function startLongTracksPolling() {
            if (longTracksIntervalId) return;
            // initial run
            fetchAndDrawLongTracks();
            longTracksIntervalId = setInterval(fetchAndDrawLongTracks, LONG_TRACKS_POLL_MS);
            if (!map.hasLayer(longTracksLayer)) longTracksLayer.addTo(map);
        }

        function stopLongTracksPolling() {
            if (longTracksIntervalId) {
                clearInterval(longTracksIntervalId);
                longTracksIntervalId = null;
            }
            try { longTracksLayer.clearLayers(); if (map.hasLayer(longTracksLayer)) map.removeLayer(longTracksLayer); } catch (e) {}
        }

        function startLiveTracksPolling() {
            if (liveTracksIntervalId) return;
            // initial run
            fetchAndDrawLiveTracks();
            liveTracksIntervalId = setInterval(fetchAndDrawLiveTracks, LIVE_TRACKS_POLL_MS);
            if (!map.hasLayer(liveTracksLayer)) liveTracksLayer.addTo(map);
        }

        function stopLiveTracksPolling() {
            if (liveTracksIntervalId) {
                clearInterval(liveTracksIntervalId);
                liveTracksIntervalId = null;
            }
            try { liveTracksLayer.clearLayers(); if (map.hasLayer(liveTracksLayer)) map.removeLayer(liveTracksLayer); } catch (e) {}
        }

        function toggleLivePositions() {
            const showLiveElem = document.getElementById('show-live');
            if (!showLiveElem) return;
            if (showLiveElem.checked) {
                startLivePositionsPolling();
            } else {
                stopLivePositionsPolling();
            }
        }

        function startLivePositionsPolling() {
            if (liveIntervalId) return;
            // initial run
            fetchLivePositions();
            liveIntervalId = setInterval(fetchLivePositions, 10000); // poll every 10 seconds
            if (!map.hasLayer(liveLayer)) liveLayer.addTo(map);
        }

        function stopLivePositionsPolling() {
            if (liveIntervalId) {
                clearInterval(liveIntervalId);
                liveIntervalId = null;
            }
            clearLiveLayer();
        }

        async function fetchAndDrawLongTracks() {
            try {
                // gather visible hexes from liveMarkers
                const bounds = map.getBounds();
                const visible = [];
                liveMarkers.forEach((marker, hex) => {
                    try {
                        const latlng = marker.getLatLng();
                        if (latlng && bounds.contains(latlng)) {
                            const lk = (hex || '').toString().toLowerCase();
                            visible.push(lk);
                        }
                    } catch (e) {}
                });
                if (visible.length === 0) {
                    // nothing to draw
                    stopLongTracksPolling();
                    return;
                }

                // clear current long tracks before redrawing
                longTracksLayer.clearLayers();

                // Use the UI-selected minutes window
                const minutesElem = document.getElementById('track-window-input');
                const minutes = minutesElem ? parseInt(minutesElem.value, 10) || 1 : 1;

                // chunk visible into batches to avoid too many parallel requests
                for (let i = 0; i < visible.length; i += LONG_TRACKS_BATCH_SIZE) {
                    const chunk = visible.slice(i, i + LONG_TRACKS_BATCH_SIZE);
                    // fetch tracks in parallel using existing fetchTrackWithCache
                    const promises = chunk.map(hx => fetchTrackWithCache(hx, minutes).catch(() => ({ points: [] })));
                    const results = await Promise.all(promises);
                    results.forEach((res, idx) => {
                        try {
                            const pts = (res && res.points) || [];
                                if (pts.length >= 2) {
                                // Compute altitude delta (if alt available) and choose color: green for climb, red for descent, yellow for static
                                let color = 'yellow'; // Default to yellow for static/level flight
                                const firstAlt = pts[0] && typeof pts[0].alt === 'number' ? pts[0].alt : null;
                                const lastAlt = pts[pts.length - 1] && typeof pts[pts.length - 1].alt === 'number' ? pts[pts.length - 1].alt : null;
                                if (firstAlt !== null && lastAlt !== null) {
                                    const delta = lastAlt - firstAlt;
                                    const thresh = 50; // altitude change threshold in feet to consider climb/descent
                                    if (delta > thresh) { color = 'green'; } // Climbing
                                    else if (delta < -thresh) { color = 'red'; } // Descending
                                    // else remains yellow for static/level flight
                                }
                                const latlngs = densifyTrackPoints(pts, 0.1);
                                // Draw historical (long) tracks on the persistent pane so they sit above overlay tiles
                                const poly = L.polyline(latlngs, { color: color, weight: 3, opacity: 0.95, pane: 'persistentPane', interactive: false });
                                // Start/end markers for context (placed on persistentPane)
                                const start = L.circleMarker(latlngs[0], { radius: 4, fillColor: '#00ff00', color: '#006600', weight: 1, fillOpacity: 0.95, pane: 'persistentPane' });
                                const end = L.circleMarker(latlngs[latlngs.length - 1], { radius: 4, fillColor: '#ff0000', color: '#660000', weight: 1, fillOpacity: 0.95, pane: 'persistentPane' });
                                const lg = L.layerGroup([poly, start, end]);
                                longTracksLayer.addLayer(lg);
                            }
                        } catch (e) {}
                    });
                }
                // ensure the layer is on the map
                if (!map.hasLayer(longTracksLayer)) longTracksLayer.addTo(map);
            } catch (err) {
                console.warn('Long tracks fetch/draw error', err);
            }
        }

        // Fetch and draw short live tracks for currently active flights (visible on the map)
        async function fetchAndDrawLiveTracks() {
            try {
                // gather visible hexes from liveMarkers
                const bounds = map.getBounds();
                const visible = [];
                liveMarkers.forEach((marker, hex) => {
                    try {
                        const latlng = marker.getLatLng();
                        if (latlng && bounds.contains(latlng)) {
                            const lk = (hex || '').toString().toLowerCase();
                            visible.push(lk);
                        }
                    } catch (e) {}
                });
                if (visible.length === 0) {
                    // nothing to draw
                    stopLiveTracksPolling();
                    return;
                }

                // clear current live tracks before redrawing
                liveTracksLayer.clearLayers();

                // Use the UI-selected minutes window
                const minutesElem = document.getElementById('track-window-input');
                const minutes = minutesElem ? Math.max(1, parseInt(minutesElem.value, 10) || 1) : 1;

                // chunk visible into batches
                for (let i = 0; i < visible.length; i += LONG_TRACKS_BATCH_SIZE) {
                    const chunk = visible.slice(i, i + LONG_TRACKS_BATCH_SIZE);
                    const promises = chunk.map(hx => fetchTrackWithCache(hx, minutes).catch(() => ({ points: [] })));
                    const results = await Promise.all(promises);
                    results.forEach((res, idx) => {
                        try {
                            const pts = (res && res.points) || [];
                                if (pts.length >= 2) {
                                // Create colored segments based on vertical rate
                                const segments = [];
                                let currentSegment = {
                                    points: [pts[0]],
                                    color: getVerticalRateColor(pts[0].vertical_rate || 0)
                                };

                                for (let i = 1; i < pts.length; i++) {
                                    const point = pts[i];
                                    const color = getVerticalRateColor(point.vertical_rate || 0);

                                    if (color === currentSegment.color) {
                                        // Continue current segment
                                        currentSegment.points.push(point);
                                    } else {
                                        // Start new segment
                                        segments.push(currentSegment);
                                        currentSegment = {
                                            points: [point],
                                            color: color
                                        };
                                    }
                                }
                                segments.push(currentSegment); // Add final segment

                                // Draw each segment
                                segments.forEach(segment => {
                                    if (segment.points.length >= 2) {
                                        const latlngs = densifyTrackPoints(segment.points, 0.1);
                                        const poly = L.polyline(latlngs, {
                                            color: segment.color,
                                            weight: 3,
                                            opacity: 0.9,
                                            pane: 'livePane',
                                            interactive: false
                                        });
                                        liveTracksLayer.addLayer(poly);
                                    }
                                });

                                // Add start/end markers
                                const start = L.circleMarker([pts[0].lat, pts[0].lon], {
                                    radius: 3,
                                    fillColor: '#00ff00',
                                    color: '#006600',
                                    weight: 1,
                                    fillOpacity: 0.9,
                                    pane: 'livePane'
                                });
                                const end = L.circleMarker([pts[pts.length - 1].lat, pts[pts.length - 1].lon], {
                                    radius: 3,
                                    fillColor: '#ff0000',
                                    color: '#660000',
                                    weight: 1,
                                    fillOpacity: 0.9,
                                    pane: 'livePane'
                                });
                                liveTracksLayer.addLayer(start);
                                liveTracksLayer.addLayer(end);
                            }
                        } catch (e) {}
                    });
                }
                // ensure the layer is on the map
                if (!map.hasLayer(liveTracksLayer)) liveTracksLayer.addTo(map);
            } catch (err) {
                console.warn('Live tracks fetch/draw error', err);
            }
        }

        function stopBatchPollingVisibleFlights() {
            if (batchPollIntervalId) {
                clearInterval(batchPollIntervalId);
                batchPollIntervalId = null;
            }
        }

        async function runBatchPollOnce() {
            if (batchPollInFlight) return; // avoid overlapping
            try {
                // Gather visible hex keys from liveMarkers that are inside map bounds
                const bounds = map.getBounds();
                const visible = [];
                liveMarkers.forEach((marker, hex) => {
                    try {
                        const latlng = marker.getLatLng();
                        if (latlng && bounds.contains(latlng)) {
                            const lk = (hex || '').toString().toLowerCase();
                            if (!flightsCache.has(lk) || (Date.now() - flightsCache.get(lk).ts) > BATCH_FLIGHT_TTL) {
                                visible.push(lk);
                            }
                        }
                    } catch (e) {}
                });
                // Include persisted tracks hexes as well so persisted tracks get enriched
                try {
                    persistentTracks.forEach((lg, hx) => {
                        try {
                            const lk = (hx || '').toString().toLowerCase();
                            if (!visible.includes(lk) && (!flightsCache.has(lk) || (Date.now() - flightsCache.get(lk).ts) > BATCH_FLIGHT_TTL)) {
                                visible.push(lk);
                            }
                        } catch (e) {}
                    });
                } catch (e) {}
                if (visible.length === 0) return;
                batchPollInFlight = true;
                // chunk into batches
                for (let i = 0; i < visible.length; i += BATCH_MAX_PER_REQUEST) {
                    const chunk = visible.slice(i, i + BATCH_MAX_PER_REQUEST);
                    const resMap = await fetchFlightsBatch(chunk);
                    // Also fetch authoritative squawk values for these hexes and merge them
                    let squawkMap = {};
                    try {
                        squawkMap = await fetchSquawksFor(chunk);
                    } catch (e) {
                        console.warn('Batch: failed to fetch squawks for chunk', e);
                        squawkMap = {};
                    }
                    // merge into cache and update markers
                        Object.keys(resMap).forEach(k => {
                            try {
                                let data = resMap[k];
                                const lk = (k || '').toString().toLowerCase();
                                // If we have a squawk for this hex from the squawkMap, ensure it's present on the flight data
                                try {
                                    const sqFromMap = (squawkMap && squawkMap[lk]) ? squawkMap[lk] : null;
                                    if (sqFromMap) {
                                        if (!data) data = {};
                                        data.sqk = data.sqk || sqFromMap;
                                        data.squawk = data.squawk || sqFromMap;
                                        lastSquawk.set(lk, sqFromMap);
                                    }
                                } catch (e) {}
                                flightsCache.set(lk, { ts: Date.now(), data });
                                const marker = liveMarkers.get(lk);
                                if (data) {
                                    // If we have a marker and it has the stored position object, merge full flight object
                                    if (marker) {
                                        try {
                                            const pos = marker._posData || { hex: lk };
                                            // Merge returned flight fields into the live position object (preserve existing non-empty values)
                                            mergePreferExisting(pos, data);
                                            // Ensure squawk is propagated from lastSquawk if missing
                                            try {
                                                if (!pos.sqk && !pos.squawk && lastSquawk.has(lk)) {
                                                    const v = lastSquawk.get(lk);
                                                    pos.sqk = v;
                                                    pos.squawk = pos.squawk || v;
                                                }
                                            } catch (e) {}
                                            marker._posData = pos;
                                            const html = buildHoverTooltipHTML(pos);
                                            // Always prefer updating existing tooltip/popup content, else bind fallback
                                            try {
                                                const tt = marker.getTooltip && marker.getTooltip();
                                                if (tt && tt.setContent) {
                                                    tt.setContent(html);
                                                    console.debug('Batch: set tooltip content for', lk);
                                                } else {
                                                    try {
                                                        marker.bindTooltip(html, { direction: 'top', offset: [0, -10], sticky: true });
                                                        console.debug('Batch: bound tooltip for', lk);
                                                    } catch (e) { console.warn('Batch: failed to bind tooltip', lk, e); }
                                                }
                                            } catch (e) { console.warn('Batch: tooltip update error', lk, e); }

                                            try {
                                                const pp = marker.getPopup && marker.getPopup();
                                                if (pp && pp.setContent) {
                                                    pp.setContent(html);
                                                    console.debug('Batch: set popup content for', lk);
                                                } else {
                                                    // bind popup as a fallback so detail is available on click
                                                    try { marker.bindPopup(html); } catch (e) { /* ignore */ }
                                                }
                                            } catch (e) { console.warn('Batch: popup update error', lk, e); }
                                        } catch (e) { console.warn('Batch: marker merge error', lk, e); }
                                    }
                                    // Update persisted track layer popups/tooltips if present
                                    try {
                                                if (persistentTracks.has(lk)) {
                                            const lg = persistentTracks.get(lk);
                                            // Build an enriched object for tooltips: prefer live marker data, then batch data, then aircraft cache
                                            try {
                                                const batchData = data || (flightsCache.get(lk) && flightsCache.get(lk).data) || {};
                                                const aircraftCached = (aircraftInfoCache.get(lk) && aircraftInfoCache.get(lk).data) || {};
                                                const liveData = (liveMarkers.get(lk) && liveMarkers.get(lk)._posData) || {};
                                                const enrich = Object.assign({}, batchData, aircraftCached, liveData, { hex: lk });
                                                // If we have a last seen squawk, ensure it's present if not in enrich
                                                try {
                                                    if (!enrich.sqk && !enrich.squawk && lastSquawk.has(lk)) {
                                                        const v = lastSquawk.get(lk);
                                                        enrich.sqk = v;
                                                        enrich.squawk = enrich.squawk || v;
                                                    }
                                                } catch (e) {}
                                                try { console.debug('Batch: enrich for', lk, enrich); } catch (e) {}
                                                var html = buildHoverTooltipHTML(enrich);
                                            } catch (e) {
                                                console.warn('Batch: failed to build enriched tooltip for', lk, e);
                                                var html = buildHoverTooltipHTML(Object.assign({ hex: lk }, data || {}));
                                            }
                                                lg.eachLayer(layer => {
                                                try {
                                                    // If a tooltip already exists, update its content; otherwise bind a new tooltip
                                                    const tt = layer.getTooltip && layer.getTooltip();
                                                    if (tt && tt.setContent) {
                                                        try { tt.setContent(html); } catch (e) {}
                                                        return;
                                                    }
                                                    // If a popup exists on the layer (polylines), update it instead
                                                    const pp = layer.getPopup && layer.getPopup();
                                                    if (pp && pp.setContent) {
                                                        try { pp.setContent(html); } catch (e) {}
                                                        return;
                                                    }
                                                    // Fallback: bind appropriate tooltip/popup
                                                        if (layer instanceof L.CircleMarker || (layer.options && layer.options.radius)) {
                                                        try { layer.bindTooltip(html, { direction: 'top', offset: [0, -8], sticky: true }); try { console.debug('Batch: bound tooltip on start/end for', lk); } catch (e) {} } catch (e) {}
                                                    } else if (layer instanceof L.Polyline) {
                                                        try { layer.bindTooltip(html, { direction: 'center', sticky: true, offset: [0, 0] }); try { console.debug('Batch: bound tooltip on polyline for', lk); } catch (e) {} } catch (e) {}
                                                    }
                                                } catch (e) {}
                                            });
                                        }
                                    } catch (e) {}
                                    // If no marker present (e.g., persisted-only), we still cached the data so when/if a marker appears it will be used
                                }
                            } catch (e) {}
                        });
                        // For any chunk hexes that did not return a flight result, still apply squawk if available
                        try {
                            for (const hx of chunk) {
                                const lk = (hx || '').toString().toLowerCase();
                                if (resMap && Object.prototype.hasOwnProperty.call(resMap, lk)) continue; // already handled
                                const sq = squawkMap && squawkMap[lk] ? squawkMap[lk] : null;
                                if (sq) {
                                    // update lastSquawk and, if a marker exists, merge and update tooltip
                                    try { lastSquawk.set(lk, sq); } catch (e) {}
                                }
                                try {
                                    const marker = liveMarkers.get(lk);
                                    if (marker) {
                                        const pos = marker._posData || { hex: lk };
                                        pos.sqk = pos.sqk || sq;
                                        pos.squawk = pos.squawk || sq;
                                        marker._posData = pos;
                                        const html = buildHoverTooltipHTML(pos);
                                        try { const tt = marker.getTooltip && marker.getTooltip(); if (tt && tt.setContent) tt.setContent(html); } catch (e) {}
                                        try { const pp = marker.getPopup && marker.getPopup(); if (pp && pp.setContent) pp.setContent(html); } catch (e) {}
                                    }
                                    // Update persisted tracks tooltips if present
                                    if (persistentTracks.has(lk)) {
                                        const lg = persistentTracks.get(lk);
                                        const batchData = flightsCache.get(lk) && flightsCache.get(lk).data ? flightsCache.get(lk).data : {};
                                        const aircraftCached = (aircraftInfoCache.get(lk) && aircraftInfoCache.get(lk).data) || {};
                                        const liveData = (liveMarkers.get(lk) && liveMarkers.get(lk)._posData) || {};
                                        const enrich = Object.assign({}, batchData, aircraftCached, liveData, { hex: lk });
                                        if (!enrich.sqk && !enrich.squawk) { enrich.sqk = sq; enrich.squawk = sq; }
                                        const html = buildHoverTooltipHTML(enrich);
                                        lg.eachLayer(layer => {
                                            try {
                                                const tt = layer.getTooltip && layer.getTooltip();
                                                if (tt && tt.setContent) { tt.setContent(html); return; }
                                                const pp = layer.getPopup && layer.getPopup();
                                                if (pp && pp.setContent) { pp.setContent(html); return; }
                                                if (layer instanceof L.CircleMarker || (layer.options && layer.options.radius)) {
                                                    layer.bindTooltip(html, { direction: 'top', offset: [0, -8], sticky: true });
                                                } else if (layer instanceof L.Polyline) {
                                                    layer.bindTooltip(html, { direction: 'center', sticky: true, offset: [0, 0] });
                                                }
                                            } catch (e) {}
                                        });
                                    }
                                } catch (e) {}
                            }
                        } catch (e) { console.warn('Batch: error merging squawks for missing flight entries', e); }
                }
            } catch (err) {
                console.warn('Batch poll error', err);
            } finally {
                batchPollInFlight = false;
            }
        }

        function cacheKey(hex, minutes) { return `${hex}|${minutes}`; }

        function getCachedTrack(hex, minutes) {
            const key = cacheKey(hex, minutes);
            const entry = trackCache.get(key);
            if (!entry) return null;
            if ((Date.now() - entry.ts) > TRACK_CACHE_TTL_MS) {
                trackCache.delete(key);
                return null;
            }
            return entry.data;
        }

        // Build rich tooltip HTML for a live position object
        function buildHoverTooltipHTML(p) {
            // Use multiple fallback field names commonly used by different sources
            const callsign = p.flight || p.callsign || p.call || p.callsign_icao || p.flight_ident || '';
            // Accept many transponder/squawk field variants and fallback to lastSquawk map if available
            const hexKey = (p.hex || '').toString().toLowerCase();
            const squawk = p.sqk || p.squawk || p.SQK || p.Squawk || p.transponder || p.transponder_code || p.squawk_code || (lastSquawk.has(hexKey) ? lastSquawk.get(hexKey) : '') || '';
            const reg = p.registration || p.Registration || p.reg || p.Reg || p.tail || '';
            const airline = p.airline || p.operator || p.operator_name || p.airline_name || p.airlineName || '';
            // Altitude: accept alt, altitude, A lt variants, or max_alt_ft from batch
            const rawAlt = (p.alt ?? p.altitude ?? p.Alt ?? p.Altitude ?? p.max_alt_ft ?? p.max_alt ?? p.alt_ft ?? '');
            const altNum = Number(rawAlt);
            const alt = (rawAlt !== '' && rawAlt != null && Number.isFinite(altNum)) ? `${altNum.toLocaleString()} ft` : (rawAlt || '');

            // Calculate vertical rate for color coding
            let verticalRate = 0;
            if (altNum && Number.isFinite(altNum)) {
                const currentTime = p.timestamp ? Number(p.timestamp) : Date.now();
                const prevData = verticalRateCache.get(hexKey);
                if (prevData && prevData.altitude && prevData.timestamp) {
                    const timeDiff = (currentTime - prevData.timestamp) / 1000; // seconds
                    if (timeDiff > 0 && timeDiff < 300) { // Only calculate if within 5 minutes
                        const altDiff = altNum - prevData.altitude; // feet
                        verticalRate = (altDiff / timeDiff) * 60; // feet per minute
                    }
                }
                // Update cache
                verticalRateCache.set(hexKey, {
                    altitude: altNum,
                    timestamp: currentTime,
                    verticalRate: verticalRate
                });
            }

            // Speed: accept gs, speed, groundSpeed, or max_speed_kt
            const rawSpeed = (p.gs ?? p.speed ?? p.groundSpeed ?? p.GS ?? p.max_speed_kt ?? p.speed_kt ?? '');
            const speedNum = Number(rawSpeed);
            const speed = (rawSpeed !== '' && rawSpeed != null && Number.isFinite(speedNum)) ? `${speedNum.toLocaleString()} kt` : (rawSpeed || '');
            // Track/heading fallbacks
            const trackVal = (typeof p.track === 'number' ? p.track : (typeof p.heading === 'number' ? p.heading : (typeof p.course === 'number' ? p.course : (typeof p.true_track === 'number' ? p.true_track : ''))));
            const track = (trackVal !== '' && trackVal != null) ? trackVal : '';
            const lat = (p.lat || p.latitude || p.Lat) || '';
            const lon = (p.lon || p.longitude || p.Lon) || '';
            const timeStr = p.timestamp ? (isNaN(Number(p.timestamp)) ? new Date(p.timestamp).toISOString() : new Date(Number(p.timestamp)).toISOString()) : '';

            // Determine airline logo
            let airlineLogoHtml = '';
            if (airline) {
                const airlineCode = airlineNameToCode.get(airline.toLowerCase());
                if (airlineCode) {
                    airlineLogoHtml = `<img src="/api/v2logos/${encodeURIComponent(airlineCode)}" alt="${airline}" style="max-width:40px;max-height:20px;margin-left:8px;vertical-align:middle;border-radius:2px;">`;
                }
            }

            return `
                <div style="min-width:200px">
                    <strong>${(p.hex||'').toUpperCase()}${callsign ? ' ‚Äî ' + callsign : ''}</strong>
                    <div>Registration: <em>${reg || '‚Äî'}</em></div>
                    <div>Airline: <em>${airline || '‚Äî'}</em>${airlineLogoHtml}</div>
                    <div>Squawk: <em>${squawk || '‚Äî'}</em></div>
                    <div>Alt: <em>${alt || '‚Äî'}</em></div>
                    <div>Speed: <em>${speed || '‚Äî'}</em></div>
                    <div>Track: <em>${track !== '' ? track + '¬∞' : '‚Äî'}</em></div>
                    <div>Pos: <em>${lat ? (typeof lat === 'number' ? lat.toFixed(5) : lat) : '‚Äî'}, ${lon ? (typeof lon === 'number' ? lon.toFixed(5) : lon) : '‚Äî'}</em></div>
                    <div>Seen: <em>${timeStr || '‚Äî'}</em></div>
                </div>`;
        }

        async function fetchTrackWithCache(hex, minutes) {
            const key = cacheKey(hex, minutes);
            const cached = getCachedTrack(hex, minutes);
            if (cached) return { points: cached, cached: true };
            if (trackFetchPromises.has(key)) return trackFetchPromises.get(key);

            const promise = (async () => {
                const res = await fetch(`/api/track?hex=${encodeURIComponent(hex)}&minutes=${minutes}`);
                if (!res.ok) throw new Error(`Track API ${res.status}`);
                const payload = await res.json();
                // Normalize track points: accept several common field names and include altitude when available.
                const pts = (payload.track || []).map(t => {
                    const lat = (t.lat ?? t.latitude ?? t.Latitude ?? t.Lat);
                    const lon = (t.lon ?? t.longitude ?? t.Longitude ?? t.Lon);
                    if (lat == null || lon == null) return null;
                    const nlat = Number(lat);
                    const nlon = Number(lon);
                    if (isNaN(nlat) || isNaN(nlon)) return null;
                    const alt = (t.alt ?? t.altitude ?? t.Altitude ?? t.Alt ?? null);
                    const nalt = (alt == null) ? null : (isNaN(Number(alt)) ? null : Number(alt));
                    return { lat: nlat, lon: nlon, alt: nalt };
                }).filter(Boolean);
                trackCache.set(key, { ts: Date.now(), data: pts });
                // Schedule a cleanup after TTL to avoid unbounded growth
                setTimeout(() => {
                    const e = trackCache.get(key);
                    if (e && ((Date.now() - e.ts) >= TRACK_CACHE_TTL_MS)) trackCache.delete(key);
                }, TRACK_CACHE_TTL_MS + 500);
                return { points: pts, cached: false };
            })();

            trackFetchPromises.set(key, promise);
            try {
                const r = await promise;
                return r;
            } finally {
                trackFetchPromises.delete(key);
            }
        }

        function clearAllPersistentTracks() {
            persistentTracks.forEach((lg, hex) => {
                persistentTracksLayer.removeLayer(lg);
            });
            persistentTracks.clear();
            updatePersistedIndicator();
        }

        function updatePersistedIndicator() {
            const el = document.getElementById('persisted-tracks-indicator');
            const listEl = document.getElementById('persisted-tracks-list');
            if (!el) return;
            const keys = [...persistentTracks.keys()];
            el.textContent = `${keys.length}`;
            if (listEl) {
                listEl.textContent = keys.length ? keys.join(', ') : '';
            }
        }

        // Update debug panel with lastSquawk and lastPositions for a hex
        function updateDebugPanel(hex) {
            const el = document.getElementById('debug-panel');
            if (!el) return;
            if (!hex) {
                el.innerHTML = 'No hex selected';
                return;
            }
            const k = (hex || '').toString().toLowerCase();
            const sq = lastSquawk.has(k) ? lastSquawk.get(k) : '‚Äî';
            const positions = lastPositions.get(k) || [];
            const posHtml = positions.length ? positions.map(p => `${(typeof p[0] === 'number' ? p[0].toFixed(5) : p[0])}, ${(typeof p[1] === 'number' ? p[1].toFixed(5) : p[1])}`).join('<br>') : '‚Äî';
            let html = `<div style="line-height:1.2"><strong>${k.toUpperCase()}</strong><br><span>Squawk: <em>${sq}</em></span><br><span>Positions:<br>${posHtml}</span></div>`;
            if (window.debugDumpEnabled) {
                // Add full JSON dumps for marker._posData, flightsCache, aircraftInfoCache
                try {
                    const marker = liveMarkers.get(k);
                    const markerData = marker && marker._posData ? marker._posData : null;
                    const flightCacheData = flightsCache.get(k) ? flightsCache.get(k).data : null;
                    const aircraftCacheData = aircraftInfoCache.get(k) ? aircraftInfoCache.get(k).data : null;
                    const dump = {
                        marker: markerData,
                        flightsCache: flightCacheData,
                        aircraftInfoCache: aircraftCacheData
                    };
                    const dumpStr = JSON.stringify(dump, null, 2);
                    html += `<pre style="max-height:160px;overflow:auto;background:#111;padding:8px;border-radius:4px;margin-top:6px;color:#ddd;font-size:11px">${escapeHtml(dumpStr)}</pre>`;
                } catch (e) {
                    html += `<div style="color:#f66">Failed to render dump: ${e.message}</div>`;
                }
            }
            el.innerHTML = html;
        }

        // Show a transient colored marker at a point for a short duration (used for squawk/track change indicators)
        function showTransientMarker(latlng, color = 'yellow', duration = 4000, radius = 5, pane = 'livePane') {
            try {
                if (!latlng) return null;
                const m = L.circleMarker(latlng, { radius: radius, fillColor: color, color: color, weight: 1, fillOpacity: 0.95, pane: pane });
                m.addTo(map);
                setTimeout(() => {
                    try { if (map.hasLayer(m)) map.removeLayer(m); } catch (e) {}
                }, duration);
                return m;
            } catch (e) { return null; }
        }

        // toggle for showing full debug dumps
        window.debugDumpEnabled = false;
        function toggleDebugDump() {
            window.debugDumpEnabled = !window.debugDumpEnabled;
            const btn = document.getElementById('toggle-debug-dump');
            if (btn) btn.textContent = window.debugDumpEnabled ? 'Hide Debug Dump' : 'Show Debug Dump';
            // refresh current panel
            try { updateDebugPanel(hoverTrackHex || [...persistentTracks.keys()][0] || null); } catch (e) {}
        }

        function escapeHtml(str) {
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        // Merge helper: copy only non-null, non-empty values from source into target
        function mergePreferExisting(target, source) {
            if (!target || !source) return target || source || {};
            Object.keys(source).forEach(k => {
                try {
                    const v = source[k];
                    if (v === undefined || v === null) return;
                    if (typeof v === 'string' && v.trim() === '') return;
                    const existing = target[k];
                    if (existing === undefined || existing === null || (typeof existing === 'string' && existing.trim() === '')) {
                        target[k] = v;
                    }
                } catch (e) {}
            });
            return target;
        }

        // Create an aircraft SVG icon (color can be changed)
        function createAircraftIcon(color = '#ff3300', size = 50, rotation = 0) {
            // Enforce minimum size of 50x50 pixels
            const finalSize = Math.max(size, 50);

            // Use new detailed aircraft SVG icon
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${finalSize}" height="${finalSize}" viewBox="0 0 36 36">
                <defs>
                    <linearGradient id="aircraftBodyGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:${color};stop-opacity:1" />
                        <stop offset="50%" style="stop-color:${color};stop-opacity:0.9" />
                        <stop offset="100%" style="stop-color:${color};stop-opacity:0.7" />
                    </linearGradient>
                    <linearGradient id="wingGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#f0f0f0;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#cccccc;stop-opacity:1" />
                    </linearGradient>
                </defs>

                <!-- Main fuselage/body -->
                <ellipse cx="18" cy="18" rx="4.5" ry="14" fill="url(#aircraftBodyGradient)" stroke="#ffffff" stroke-width="0.8"/>

                <!-- Wings (main) -->
                <rect x="6" y="16.5" width="24" height="3" rx="1" fill="url(#wingGradient)" stroke="#ffffff" stroke-width="0.5"/>
                <rect x="7" y="17" width="22" height="2" rx="0.5" fill="${color}" opacity="0.9"/>

                <!-- Tail section -->
                <rect x="16" y="4" width="4" height="8" rx="0.5" fill="url(#aircraftBodyGradient)" stroke="#ffffff" stroke-width="0.5"/>
                <rect x="16.5" y="4.5" width="3" height="7" rx="0.3" fill="${color}" opacity="0.8"/>

                <!-- Vertical stabilizer -->
                <rect x="17.2" y="2" width="1.6" height="6" rx="0.2" fill="url(#wingGradient)" stroke="#ffffff" stroke-width="0.3"/>
                <rect x="17.4" y="2.2" width="1.2" height="5.6" rx="0.1" fill="${color}" opacity="0.9"/>

                <!-- Horizontal stabilizers -->
                <rect x="14" y="5" width="8" height="2" rx="0.3" fill="url(#wingGradient)" stroke="#ffffff" stroke-width="0.3"/>
                <rect x="14.5" y="5.2" width="7" height="1.6" rx="0.2" fill="${color}" opacity="0.8"/>

                <!-- Engines (turbofan style) -->
                <circle cx="9" cy="18" r="2" fill="#333333" stroke="#ffffff" stroke-width="0.3"/>
                <circle cx="9" cy="18" r="1.2" fill="#666666"/>
                <circle cx="27" cy="18" r="2" fill="#333333" stroke="#ffffff" stroke-width="0.3"/>
                <circle cx="27" cy="18" r="1.2" fill="#666666"/>

                <!-- Cockpit windows -->
                <rect x="16" y="7" width="4" height="3" rx="2" fill="#87ceeb" opacity="0.8" stroke="#ffffff" stroke-width="0.2"/>
                <rect x="16.5" y="7.5" width="3" height="2" rx="1.5" fill="#4682b4" opacity="0.6"/>

                <!-- Wing flaps/ailerons (subtle) -->
                <rect x="8" y="19.5" width="4" height="1" rx="0.2" fill="#666666" opacity="0.7"/>
                <rect x="24" y="19.5" width="4" height="1" rx="0.2" fill="#666666" opacity="0.7"/>

                <!-- Landing gear doors (subtle) -->
                <rect x="12" y="30" width="2" height="1.5" rx="0.3" fill="#666666" opacity="0.5"/>
                <rect x="22" y="30" width="2" height="1.5" rx="0.3" fill="#666666" opacity="0.5"/>
            </svg>`;

            const html = `<div style="transform: rotate(${rotation}deg); width: ${finalSize}px; height:${finalSize}px; display:flex; align-items:center; justify-content:center">${svg}</div>`;
            return L.divIcon({
                html,
                className: 'aircraft-icon',
                iconSize: [finalSize, finalSize],
                iconAnchor: [finalSize/2, finalSize/2]
            });
        }

        // Compute icon rotation so the nose points along the track
        function iconRotationFromTrack(track) {
            const t = (typeof track === 'number' && !isNaN(track)) ? Number(track) : 0;
            return t;
        }

        // Aircraft icon mappings from dump1090-fa
        const TypeDesignatorIcons = {
            'A10': 'hi_perf', 'A148': 'hi_perf', 'A21N': 'airliner', 'A225': 'heavy_4e', 'A3': 'hi_perf', 'A359': 'airliner',
            'A37': 'jet_nonswept', 'A388': 'heavy_4e', 'A5': 'cessna', 'A6': 'hi_perf', 'A700': 'jet_nonswept', 'AC80': 'twin_small', 'AC90': 'twin_small',
            'AC95': 'twin_small', 'AJ27': 'jet_nonswept', 'AJET': 'hi_perf', 'AN28': 'twin_small', 'ARCE': 'hi_perf',
            'AT3': 'hi_perf', 'ATG1': 'jet_nonswept', 'B18T': 'twin_small', 'B190': 'twin_small', 'B25': 'twin_large',
            'B350': 'twin_small', 'B52': 'heavy_4e', 'B712': 'jet_swept', 'B721': 'airliner', 'B722': 'airliner',
            'B738': 'airliner', 'B763': 'airliner', 'B77W': 'heavy_2e', 'BALL': 'balloon', 'BE10': 'twin_small', 'BE20': 'twin_small', 'BE30': 'twin_small', 'BE32': 'twin_small',
            'BE40': 'jet_nonswept', 'BE99': 'twin_small', 'BE9L': 'twin_small', 'BE9T': 'twin_small', 'BN2T': 'twin_small',
            'BPOD': 'jet_swept', 'BU20': 'twin_small', 'C08T': 'jet_swept', 'C125': 'twin_small', 'C212': 'twin_small',
            'C21T': 'twin_small', 'C22J': 'jet_nonswept', 'C25A': 'jet_nonswept', 'C25B': 'jet_nonswept', 'C25C': 'jet_nonswept',
            'C25D': 'jet_nonswept', 'C441': 'jet_swept', 'C500': 'jet_nonswept', 'C501': 'jet_nonswept', 'C510': 'jet_nonswept',
            'C525': 'jet_nonswept', 'C550': 'jet_nonswept', 'C560': 'jet_nonswept', 'C56X': 'jet_nonswept', 'C650': 'jet_swept',
            'C680': 'jet_swept', 'C750': 'jet_swept', 'CL30': 'jet_swept', 'CL35': 'jet_swept', 'CL60': 'jet_swept',
            'CL85': 'jet_swept', 'CN35': 'jet_swept', 'CRJ1': 'jet_swept', 'CRJ2': 'jet_swept', 'CRJ7': 'jet_swept',
            'CRJ9': 'jet_swept', 'CRJX': 'jet_swept', 'CVLP': 'twin_large', 'D228': 'twin_small', 'DA36': 'hi_perf',
            'DA50': 'airliner', 'DC10': 'heavy_2e', 'DC3': 'twin_large', 'DC3S': 'twin_large', 'DHA3': 'twin_small',
            'DHC6': 'twin_small', 'DLH2': 'hi_perf', 'E110': 'twin_small', 'E135': 'jet_swept', 'E145': 'jet_swept',
            'E29E': 'hi_perf', 'E45X': 'jet_swept', 'E500': 'jet_nonswept', 'E50P': 'jet_nonswept', 'E545': 'jet_swept',
            'E55P': 'jet_nonswept', 'EA50': 'jet_nonswept', 'EFAN': 'jet_nonswept', 'EFUS': 'hi_perf', 'ELIT': 'jet_nonswept',
            'EUFI': 'hi_perf', 'F1': 'hi_perf', 'F100': 'jet_swept', 'F111': 'hi_perf', 'F117': 'hi_perf', 'F14': 'hi_perf',
            'F15': 'hi_perf', 'F22': 'hi_perf', 'F2TH': 'jet_swept', 'F4': 'hi_perf', 'F406': 'twin_small', 'F5': 'hi_perf',
            'F50': 'twin_large', 'F70': 'twin_large', 'FA10': 'hi_perf', 'FA20': 'hi_perf', 'FA50': 'hi_perf', 'FA7X': 'hi_perf',
            'FJET': 'jet_nonswept', 'G115': 'twin_small', 'G120': 'twin_small', 'G150': 'jet_nonswept', 'G159': 'jet_nonswept',
            'G200': 'jet_nonswept', 'G280': 'jet_nonswept', 'G3': 'jet_nonswept', 'G4': 'jet_nonswept', 'G450': 'jet_nonswept',
            'G5': 'jet_nonswept', 'G550': 'jet_nonswept', 'G650': 'jet_swept', 'GALX': 'jet_swept', 'GL5T': 'jet_swept',
            'GLF2': 'jet_nonswept', 'GLF3': 'jet_nonswept', 'GLF4': 'jet_nonswept', 'GLF5': 'jet_nonswept', 'GLF6': 'jet_swept',
            'H25A': 'jet_swept', 'H25B': 'jet_swept', 'H25C': 'jet_swept', 'HA4T': 'airliner', 'HDJT': 'jet_nonswept',
            'HERN': 'jet_swept', 'J8A': 'hi_perf', 'J8B': 'hi_perf', 'JH7': 'hi_perf', 'JS31': 'twin_small', 'JS32': 'twin_small',
            'JU52': 'twin_small', 'L101': 'heavy_2e', 'LAE1': 'hi_perf', 'LEOP': 'jet_nonswept', 'LJ23': 'jet_nonswept',
            'LJ24': 'jet_nonswept', 'LJ25': 'jet_nonswept', 'LJ28': 'jet_nonswept', 'LJ31': 'jet_nonswept', 'LJ35': 'jet_nonswept',
            'LJ45': 'jet_nonswept', 'LJ55': 'jet_nonswept', 'LJ60': 'jet_nonswept', 'LJ75': 'jet_swept', 'LJ85': 'jet_swept',
            'M20P': 'twin_small', 'M7': 'hi_perf', 'MD11': 'heavy_2e', 'MD81': 'airliner', 'MD82': 'airliner', 'MD83': 'airliner',
            'MD87': 'airliner', 'MD88': 'airliner', 'MD90': 'airliner', 'MU2': 'twin_small', 'MU30': 'twin_small', 'N262': 'twin_small',
            'P180': 'twin_small', 'P28A': 'cessna', 'P28B': 'cessna', 'P28R': 'cessna', 'P28S': 'cessna', 'P28T': 'cessna',
            'P28U': 'cessna', 'P32R': 'cessna', 'P32T': 'cessna', 'P46T': 'twin_small', 'PA23': 'twin_small', 'PA24': 'twin_small',
            'PA25': 'twin_small', 'PA27': 'twin_small', 'PA30': 'twin_small', 'PA31': 'twin_small', 'PA32': 'twin_small',
            'PA34': 'twin_small', 'PA44': 'twin_small', 'PA46': 'twin_small', 'PC12': 'twin_small', 'PC6T': 'twin_small',
            'PC9': 'twin_small', 'PRM1': 'jet_nonswept', 'R22': 'helicopter', 'R44': 'helicopter', 'RJ1H': 'jet_swept',
            'RJ70': 'jet_swept', 'RJ85': 'jet_swept', 'RJ100': 'jet_swept', 'S3': 'hi_perf', 'S37': 'jet_nonswept',
            'S601': 'jet_nonswept', 'SATA': 'jet_nonswept', 'SB05': 'jet_nonswept', 'SC7': 'twin_small', 'SF50': 'jet_nonswept',
            'SJ30': 'jet_nonswept', 'SLCH': 'heavy_4e', 'SM60': 'twin_small', 'SOL1': 'jet_swept', 'SOL2': 'jet_swept',
            'SP33': 'jet_nonswept', 'SR71': 'hi_perf', 'SS2': 'hi_perf', 'SU15': 'hi_perf', 'SU24': 'hi_perf', 'SU25': 'hi_perf',
            'SU27': 'hi_perf', 'SW2': 'twin_small', 'SW3': 'twin_small', 'SW4': 'twin_small', 'T154': 'airliner', 'T2': 'jet_nonswept',
            'T22M': 'hi_perf', 'T37': 'jet_nonswept', 'T38': 'jet_nonswept', 'T4': 'hi_perf', 'TJET': 'jet_nonswept', 'TOR': 'hi_perf',
            'TRIM': 'twin_small', 'TRIS': 'twin_small', 'TRMA': 'twin_small', 'TU22': 'hi_perf', 'VAUT': 'hi_perf', 'Y130': 'hi_perf',
            'Y141': 'airliner', 'YK28': 'hi_perf', 'YK38': 'airliner', 'YK40': 'airliner', 'YK42': 'airliner', 'YURO': 'hi_perf'
        };

        const TypeDescriptionIcons = {
            'H': 'helicopter',
            'L1P': 'cessna', 'L1T': 'cessna', 'L1J': 'hi_perf',
            'L2P': 'twin_small', 'L2T': 'twin_large',
            'L2J-L': 'jet_swept', 'L2J-M': 'airliner', 'L2J-H': 'heavy_2e',
            'L3J-L': 'jet_swept', 'L3J-M': 'airliner', 'L3J-H': 'heavy_2e',
            'L4J-L': 'jet_swept', 'L4J-M': 'airliner', 'L4J-H': 'heavy_4e',
            'L2J-M': 'airliner', 'L2J-H': 'heavy_2e',
            'L4T': 'heavy_4e', 'L4J-H': 'heavy_4e'
        };

        const CategoryIcons = {
            'A1': 'cessna', 'A2': 'jet_nonswept', 'A3': 'airliner', 'A4': 'heavy_2e', 'A5': 'heavy_4e', 'A6': 'hi_perf', 'A7': 'helicopter',
            'B1': 'cessna', 'B2': 'balloon', 'B4': 'cessna', 'B7': 'hi_perf',
            'C0': 'ground_unknown', 'C1': 'ground_emergency', 'C2': 'ground_service', 'C3': 'ground_fixed', 'C4': 'ground_fixed', 'C5': 'ground_fixed', 'C6': 'ground_unknown', 'C7': 'ground_unknown'
        };

        // Function to get icon name for aircraft based on type
        function getIconForAircraft(info) {
            // Try type designator first (most specific)
            if (info.typecode && TypeDesignatorIcons[info.typecode]) {
                return TypeDesignatorIcons[info.typecode];
            }

            // Try category
            if (info.category && CategoryIcons[info.category]) {
                return CategoryIcons[info.category];
            }

            // Try type description
            if (info.type_description && TypeDescriptionIcons[info.type_description]) {
                return TypeDescriptionIcons[info.type_description];
            }

            // Default to generic aircraft icon
            return 'aircraft';
        }

        // Create an aircraft logo icon (image) using known aircraft info.
        // `info` may contain `manufacturerLogo` (relative URL) or `manufacturer`/`aircraft_model`.
        function createAircraftLogoIcon(info = {}, rotation = 0, size = 50, verticalRate = 0) {
            // Enforce minimum size of 50x50 pixels
            const finalSize = Math.max(size, 50);

            // Determine color based on vertical rate (feet per minute)
            let color = '#ff3300'; // default red
            if (verticalRate > 500) {
                color = '#00ff00'; // green for climbing
            } else if (verticalRate < -500) {
                color = '#ff0000'; // red for descending
            } else {
                color = '#9900ff'; // purple for level flight
            }

            // Determine image source - use only aircraft type icons
            let src = null;
            try {
                // Use aircraft type icons only
                const icon = getIconForAircraft(info);
                if (icon && icon !== 'aircraft') {
                    src = `/icons/${icon}.svg`;
                } else {
                    // Fallback to generic aircraft icon
                    src = `/icons/aircraft.svg`;
                }
            } catch (e) {}
            // Fallback to simple aircraft SVG from piaware/dump1090-fa style
            const imgHtml = src ? `<img src="${src}" alt="aircraft" style="width:${finalSize}px;height:${finalSize}px;object-fit:contain;display:block;border-radius:3px;border:1px solid rgba(255,255,255,0.3);filter: drop-shadow(0 0 3px ${color});"/>` : `<svg xmlns="http://www.w3.org/2000/svg" width="${finalSize}" height="${finalSize}" viewBox="0 0 36 36">
                <defs>
                    <style>.cls-1{fill:${color};}.cls-2{fill:#ffffff;}</style>
                </defs>
                <g>
                    <path class="cls-1" d="M18,4l2,4h8l-6,4,2,6-6-4-6,4,2-6-6-4h8Z"/>
                    <path class="cls-2" d="M18,5l1.5,3h6l-4.5,3,1.5,4.5-4.5-3-4.5,3,1.5-4.5-4.5-3h6Z" opacity="0.3"/>
                </g>
            </svg>`;
            const html = `<div style="transform: rotate(${rotation}deg); width: ${finalSize}px; height:${finalSize}px; display:flex; align-items:center; justify-content:center">${imgHtml}</div>`;
            return L.divIcon({ html, className: 'aircraft-logo-icon', iconSize: [finalSize, finalSize], iconAnchor: [finalSize/2, finalSize/2] });
        }

        // Add minimal CSS for aircraft icons
        const style = document.createElement('style');
        style.innerHTML = `
            .aircraft-icon svg {
                display:block;
                filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
            }
            .aircraft-icon {
                pointer-events: auto;
                border-radius: 4px;
                transition: transform 0.2s ease;
            }
            .aircraft-icon:hover {
                transform: scale(1.1);
            }
            .aircraft-logo-icon img {
                display:block;
                filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
            }
            .aircraft-logo-icon {
                pointer-events:auto;
                border-radius: 4px;
                transition: transform 0.2s ease;
            }
            .aircraft-logo-icon:hover {
                transform: scale(1.1);
            }
        `;
        document.head.appendChild(style);
        function clearLiveLayer() {
            if (liveLayer) {
                // remove layer from map and clear stored markers
                liveLayer.clearLayers();
                if (map.hasLayer(liveLayer)) map.removeLayer(liveLayer);
            }
            // remove and forget markers
            liveMarkers.forEach((m) => {
                try { if (map.hasLayer(m)) map.removeLayer(m); } catch (e) {}
            });
            liveMarkers.clear();
        }

        async function fetchLivePositions() {
            try {
                setLiveStatus('Fetching...', 'loading');
                const timeWindow = document.getElementById('time-window').value;
                // reuse windowToHours helper
                function windowToHours(w) {
                    if (!w) return 24;
                    if (w === 'all') return 744;
                    if (w.endsWith('d')) {
                        const days = parseInt(w.replace('d',''), 10);
                        return isNaN(days) ? 24 : days * 24;
                    }
                    if (w.endsWith('h')) {
                        const hrs = parseInt(w.replace('h',''), 10);
                        return isNaN(hrs) ? 24 : hrs;
                    }
                    return 24;
                }
                // When showing live positions, prefer a short lookback so we only
                // display currently active aircraft. The main `time-window` UI
                // controls the heatmap grid and may be set to large ranges (24h,
                // 7d). Override that for live polling to avoid plotting historical
                // positions as live markers.
                let hours = windowToHours(timeWindow);
                try {
                    const showLiveElem = document.getElementById('show-live');
                    if (showLiveElem && showLiveElem.checked) {
                        // Use a short, sensible default (1 hour) for live marker polling
                        hours = 1;
                    }
                } catch (e) {}
                // Fetch live positions from backend `/api/positions` using selected time window
                const res = await fetch(`/api/positions?hours=${hours}`);
                if (!res.ok) throw new Error(`Positions API error: ${res.status}`);
                const payload = await res.json();
                // Server returns { aircraftCount, positions } ‚Äî normalize to an array
                let positions = Array.isArray(payload.positions) ? payload.positions : (Array.isArray(payload) ? payload : []);

                // Filter positions to only show currently live aircraft.
                // Build a map of positions grouped by hex and keep the most recent
                // point per hex. Also seed short tail points from recent history so
                // the live track (tail) can be drawn without showing long historical
                // data. Use a short recency window (2 minutes) to determine "live".
                try {
                    const RECENT_MS = 2 * 60 * 1000; // 2 minutes
                    const nowTs = Date.now();
                    const positionsByHex = new Map();
                    positions.forEach(p => {
                        const hx = (p.hex || p.HEX || p.icao || p.icao24 || '').toLowerCase();
                        const ts = p.timestamp || p.ts || p.time || 0;
                        if (!hx) return;
                        if (!positionsByHex.has(hx)) positionsByHex.set(hx, []);
                        positionsByHex.get(hx).push(Object.assign({}, p, { timestamp: ts }));
                    });

                    const filtered = [];
                    for (const [hex, arr] of positionsByHex.entries()) {
                        // Sort descending by timestamp so arr[0] is newest
                        arr.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                        const latest = arr[0];
                        if (!latest) continue;
                        // Only include aircraft seen within RECENT_MS
                        if ((latest.timestamp || nowTs) < (nowTs - RECENT_MS)) continue;

                        // Seed short trail points (chronological order) from most recent
                        try {
                            const pts = arr.slice(0, LAST_POSITIONS_COUNT).map(p => [p.lat ?? p.Latitude ?? p.latitude, p.lon ?? p.Longitude ?? p.longitude]).reverse();
                            if (pts && pts.length) lastPositions.set(hex, pts);
                        } catch (e) {}

                        filtered.push(latest);
                    }

                    positions = filtered;
                } catch (e) {
                    // If filtering fails for any reason, fall back to unfiltered list
                    console.warn('Live positions filtering failed', e);
                }

                // Prefetch aircraft info for all visible hexes using batch endpoint to reduce requests
                try {
                    const needed = [];
                    const seenSet = new Set();
                    positions.forEach(p => {
                        const hx = (p.hex || '').toLowerCase();
                        if (!hx) return;
                        if (seenSet.has(hx)) return;
                        seenSet.add(hx);
                        const cached = aircraftInfoCache.get(hx);
                        if (!cached || !cached.data) {
                            needed.push(hx);
                        }
                    });
                    if (needed.length > 0) {
                        // POST { icao24: [...] } expected by server
                        const batchRes = await fetch('/api/aircraft/batch', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ icao24: needed })
                        });
                        if (batchRes.ok) {
                            const batchPayload = await batchRes.json();
                            const results = batchPayload.results || {};
                            Object.keys(results).forEach(k => {
                                const lk = k.toLowerCase();
                                aircraftInfoCache.set(lk, { ts: Date.now(), data: results[k] });
                            });
                            // mark not-found entries to avoid repeated requests
                            needed.forEach(h => {
                                const lk = h.toLowerCase();
                                if (!aircraftInfoCache.has(lk)) aircraftInfoCache.set(lk, { ts: Date.now(), data: null });
                            });
                        }
                    }
                } catch (err) {
                    console.warn('Batch aircraft lookup failed', err);
                }

                // Update live layer contents: update existing markers in-place for smooth movement
                const seenHexes = new Set();
                positions.forEach(p => {
                    const lat = p.lat ?? p.Latitude ?? p.latitude;
                    const lon = p.lon ?? p.Longitude ?? p.longitude;
                    if (typeof lat !== 'number' || typeof lon !== 'number') return;
                    const hex = (p.hex || '').toLowerCase();
                    seenHexes.add(hex);

                    // Calculate vertical rate for color coding (used for both new and existing markers)
                    let verticalRate = 0;
                    try {
                        const alt = p.alt || p.altitude || p.Alt || p.Altitude || null;
                        if (alt !== null && typeof alt === 'number') {
                            const now = Date.now();
                            const prevData = verticalRateCache.get(hex);
                            if (prevData) {
                                const timeDiff = (now - prevData.timestamp) / 1000; // seconds
                                if (timeDiff > 0 && timeDiff < 300) { // within 5 minutes
                                    const altDiff = alt - prevData.altitude; // feet
                                    verticalRate = (altDiff / timeDiff) * 60; // feet per minute
                                }
                            }
                            // Update cache
                            verticalRateCache.set(hex, { altitude: alt, timestamp: now });
                        }
                    } catch (e) {}

                    // Merge cached aircraft info into position object for tooltip/popups
                    try {
                        const cachedInfo = aircraftInfoCache.get(hex);
                        if (cachedInfo && cachedInfo.data) {
                            const info = cachedInfo.data;
                            p.registration = p.registration || info.registration || info.reg || info.tail || p.registration;
                            p.airline = p.airline || info.operator || info.airline || info.operator_name || p.airline;
                        }
                    } catch (e) {}

                    // Record any squawk we saw for this hex so it can be used by persisted tracks
                    try {
                        const s = p.sqk || p.squawk || p.SQK || p.Squawk || p.transponder || p.transponder_code || null;
                        if (s) lastSquawk.set(hex, s);
                    } catch (e) {}

                    // Calculate rotation if heading/track is available
                    const rot = (typeof p.track === 'number' && !isNaN(p.track)) ? p.track : (typeof p.heading === 'number' ? p.heading : 0);

                    // If there's an existing marker, move it smoothly by setting its position and updating icon
                    if (liveMarkers.has(hex)) {
                        const existing = liveMarkers.get(hex);
                        try {
                            // Merge live position with any existing enriched data so we don't lose batch-enriched fields
                            try {
                                // detect previous squawk and track for change indicators
                                const prevSqk = existing._posData && (existing._posData.sqk || existing._posData.squawk) ? (existing._posData.sqk || existing._posData.squawk) : null;
                                const prevTrack = existing._posData && typeof existing._posData.track === 'number' ? existing._posData.track : (existing._posData && existing._posData.track ? Number(existing._posData.track) : null);

                                const merged = Object.assign({}, existing._posData || {}, p);
                                try {
                                    if (!merged.sqk && !merged.squawk && lastSquawk.has(hex)) {
                                        const v = lastSquawk.get(hex);
                                        merged.sqk = v;
                                        merged.squawk = merged.squawk || v;
                                    }
                                } catch (e) {}
                                existing._posData = merged;

                                // squawk changed? show a transient yellow marker at current position
                                try {
                                    const newSqk = merged.sqk || merged.squawk || null;
                                    if (prevSqk && newSqk && prevSqk !== newSqk) {
                                        try { showTransientMarker(existing.getLatLng(), 'yellow', 4000, 6); } catch (e) {}
                                    }
                                } catch (e) {}

                                // track changed significantly? show a transient blue marker
                                try {
                                    const newTrack = (typeof merged.track === 'number' && !isNaN(merged.track)) ? merged.track : (merged.track ? Number(merged.track) : null);
                                    if (prevTrack !== null && newTrack !== null && Math.abs(newTrack - prevTrack) > 5) {
                                        try { showTransientMarker(existing.getLatLng(), 'blue', 3000, 5); } catch (e) {}
                                    }
                                } catch (e) {}

                                try { console.debug('Live: merged marker._posData for', hex, merged); } catch (e) {}
                            } catch (e) {
                                existing._posData = p;
                                try { console.debug('Live: set marker._posData (no merge) for', hex, p); } catch (e) {}
                            }
                            const oldLatLng = existing.getLatLng ? existing.getLatLng() : null;
                            existing.setLatLng([lat, lon]);
                            // update icon rotation by modifying the existing DOM element rather than recreating the icon
                            const el = (existing.getElement && existing.getElement()) || existing._icon;
                            if (el) {
                                // our createAircraftIcon wraps the svg in a div, update its transform
                                const inner = el.querySelector && el.querySelector('div');
                                if (inner) inner.style.transform = `rotate(${rot || 0}deg)`;
                            }

                            // Update icon color based on vertical rate change
                            try {
                                const prevVerticalRate = existing._verticalRate || 0;
                                if (Math.abs(verticalRate - prevVerticalRate) > 100) { // significant change
                                    const aircraftInfo = {
                                        manufacturer: p.manufacturer || p.airline || null,
                                        typecode: p.aircraft_type || null
                                    };
                                    const newIcon = createAircraftLogoIcon(aircraftInfo, rot || 0, 50, verticalRate);
                                    existing.setIcon(newIcon);
                                    existing._verticalRate = verticalRate;
                                }
                            } catch (e) {
                                // ignore icon update errors
                            }

                            // update tooltip content from merged marker._posData (preserve batch-enriched fields)
                            const tooltipHtml = buildHoverTooltipHTML(existing._posData || p);
                            try {
                                const tt = existing.getTooltip && existing.getTooltip();
                                if (tt && tt.setContent) {
                                    tt.setContent(tooltipHtml);
                                    try { console.debug('Live: updated tooltip for', hex); } catch (e) {}
                                } else {
                                    existing.bindTooltip(tooltipHtml, { direction: 'top', offset: [0, -10], sticky: true });
                                    try { console.debug('Live: bound tooltip for', hex); } catch (e) {}
                                }
                            } catch (e) {
                                // ignore tooltip update errors
                            }

                            // update popup content as well
                            try {
                                const popup = existing.getPopup && existing.getPopup();
                                if (popup && popup.setContent) {
                                    popup.setContent(tooltipHtml);
                                    try { console.debug('Live: updated popup for', hex); } catch (e) {}
                                }
                            } catch (e) {}

                            // Maintain last N valid positions for this hex and draw a short tail
                            try {
                                const arr = lastPositions.get(hex) || [];
                                const last = arr.length ? arr[arr.length - 1] : null;
                                // push only if position changed
                                if (!last || last[0] !== lat || last[1] !== lon) {
                                    arr.push([lat, lon]);
                                    if (arr.length > LAST_POSITIONS_COUNT) arr.splice(0, arr.length - LAST_POSITIONS_COUNT);
                                    lastPositions.set(hex, arr);
                                }

                                const pts = (lastPositions.get(hex) || []).slice();
                                if (pts.length >= 2) {
                                    if (liveTrails.has(hex)) {
                                        const tr = liveTrails.get(hex);
                                        try { tr.setLatLngs(pts); } catch (e) {}
                                    } else {
                                        const tr = L.polyline(pts, { color: '#00ffff', weight: 2, opacity: 0.7, pane: 'livePane', interactive: false });
                                        liveTrails.set(hex, tr);
                                        liveLayer.addLayer(tr);
                                    }
                                } else {
                                    // remove any existing short trail if we don't have at least two points
                                    if (liveTrails.has(hex)) {
                                        const tr = liveTrails.get(hex);
                                        try { liveLayer.removeLayer(tr); if (map.hasLayer(tr)) map.removeLayer(tr); } catch (e) {}
                                        liveTrails.delete(hex);
                                    }
                                }

                                // Compute bearing using the last two valid positions if track not provided
                                try {
                                    const mp = existing._posData || {};
                                    if ((!mp.track && typeof mp.track !== 'number') || mp.track === '') {
                                        const curPts = lastPositions.get(hex) || [];
                                        if (curPts.length >= 2) {
                                            const a = curPts[curPts.length - 2];
                                            const b = curPts[curPts.length - 1];
                                            const bng = computeBearing(a[0], a[1], b[0], b[1]);
                                            if (bng != null) {
                                                try { mp.track = bng; existing._posData = mp; } catch (e) {}
                                                try { console.debug('Live: computed track for', hex, bng); } catch (e) {}
                                            }
                                        }
                                    }
                                } catch (e) {}
                            } catch (e) {}
                        } catch (e) {
                            console.warn('Failed to update marker for', hex, e);
                        }
                        return;
                    }

                    // Otherwise create new marker and add to layer
                    // Try to use logo icon if manufacturer info is available, otherwise use SVG icon
                    let icon;
                    try {
                        const aircraftInfo = {
                            manufacturer: p.manufacturer || p.airline || null,
                            typecode: p.aircraft_type || null
                        };
                        if (aircraftInfo.manufacturer || aircraftInfo.typecode) {
                            icon = createAircraftLogoIcon(aircraftInfo, rot || 0, 50, verticalRate);
                        } else {
                            icon = createAircraftIcon('#ff3300', 50, rot || 0);
                        }
                    } catch (e) {
                        // Fallback to SVG icon if logo creation fails
                        icon = createAircraftIcon('#ff3300', 50, rot || 0);
                    }
                    const marker = L.marker([lat, lon], { icon, pane: 'livePane', zIndexOffset: 1000 });

                    // Tooltip shown on hover (richer HTML)
                    const tooltipHtml = buildHoverTooltipHTML(p);
                    marker.bindTooltip(tooltipHtml, { direction: 'top', offset: [0, -10], sticky: true });

                    // Ensure initial posData includes squawk fallback and seed recent positions
                    try {
                        const v = p.sqk || p.squawk || p.transponder || p.transponder_code || p.squawk_code || null;
                        if (v) { p.sqk = v; p.squawk = p.squawk || v; }
                        else if (lastSquawk.has(hex)) { const ls = lastSquawk.get(hex); if (ls) { p.sqk = ls; p.squawk = p.squawk || ls; } }
                    } catch (e) {}
                    try { lastPositions.set(hex, [[lat, lon]]); } catch (e) {}

                    // If registration/airline missing, try fetching from server aircraft DB
                    (async () => {
                            try {
                                const info = await fetchAircraftInfo(hex);
                                if (info) {
                                    // merge fields onto p for tooltip generation
                                    p.registration = p.registration || info.registration || info.reg || info.tail || p.registration;
                                    p.airline = p.airline || info.operator || info.airline || info.operator_name || p.airline;
                                }
                            } catch (e) {}
                            // ensure marker._posData is up-to-date and remember squawk
                            try {
                                marker._posData = p;
                                const s = p.sqk || p.squawk || p.SQK || p.Squawk || null;
                                try { if (s) lastSquawk.set(hex, s); } catch (e) {}
                                const newHtml = buildHoverTooltipHTML(p);
                                try { if (marker.getTooltip && marker.getTooltip().setContent) marker.getTooltip().setContent(newHtml); else marker.bindTooltip(newHtml, { direction: 'top', offset: [0, -10], sticky: true }); } catch (e) {}
                                try { if (marker.getPopup && marker.getPopup().setContent) marker.getPopup().setContent(newHtml); } catch (e) {}
                            } catch (e) {}
                    })();

                    // On hover, fetch (with cache/debounce) and display recent track for this aircraft
                    marker.on('mouseover', (ev) => {
                        try {
                            if (!hex) return;
                            // cancel any pending clear
                            if (hoverClearTimer) { clearTimeout(hoverClearTimer); hoverClearTimer = null; }
                            // debounce actual fetch/draw to avoid rapid requests when moving across markers
                            if (hoverFetchTimer) clearTimeout(hoverFetchTimer);
                            hoverFetchTimer = setTimeout(async () => {
                                try {
                                    if (!hex) return;
                                    if (hoverTrackHex === hex) return;
                                    hoverTrackHex = hex;
                                    try { updateDebugPanel(hex); } catch (e) {}
                                    // Clear any previous hover-only track
                                    trackLayer.clearLayers();

                                    // Use the UI-selected track window (minutes)
                                    const minutesElem = document.getElementById('track-window-input');
                                    const minutes = minutesElem ? parseInt(minutesElem.value, 10) || 1 : 1;
                                    setTrackStatus('Fetching...', 'loading');

                                    try {
                                        const { points, cached } = await fetchTrackWithCache(hex, minutes);
                                        if (points.length > 0) {
                                                    // compute color based on altitude change if available: green for climb, red for descent, yellow for static
                                                    let color = 'yellow'; // Default to yellow for static/level flight
                                                    const firstAlt = points[0] && typeof points[0].alt === 'number' ? points[0].alt : null;
                                                    const lastAlt = points[points.length - 1] && typeof points[points.length - 1].alt === 'number' ? points[points.length - 1].alt : null;
                                                    if (firstAlt !== null && lastAlt !== null) {
                                                        const delta = lastAlt - firstAlt;
                                                        const thresh = 50;
                                                        if (delta > thresh) { color = 'green'; } // Climbing
                                                        else if (delta < -thresh) { color = 'red'; } // Descending
                                                        // else remains yellow for static/level flight
                                                    }
                                                    const latlngs = densifyTrackPoints(points, 0.1);
                                                    const poly = L.polyline(latlngs, { color: color, weight: 3, opacity: 0.9, pane: 'livePane', interactive: false });
                                                    const start = L.circleMarker(latlngs[0], { radius: 3, fillColor: '#00ff00', color: '#006600', weight: 1, fillOpacity: 0.9, pane: 'livePane' });
                                                    const end = L.circleMarker(latlngs[latlngs.length - 1], { radius: 3, fillColor: '#ff0000', color: '#660000', weight: 1, fillOpacity: 0.9, pane: 'livePane' });
                                                    // group for easy removal
                                                    const lg = L.layerGroup([poly, start, end]);
                                                    trackLayer.addLayer(lg);
                                                    trackLayer.addTo(map);
                                                    setTrackStatus(formatOkWithTime(`OK (${points.length})${cached ? ' (cached)' : ''}`), 'ok');
                                                } else {
                                            setTrackStatus('No data', 'error');
                                        }
                                    } catch (err) {
                                        console.warn('Failed to fetch/show track for', hex, err);
                                        setTrackStatus('Error', 'error');
                                    }
                                    // Begin polling flight details (1 Hz) and update tooltip while hovering
                                    try { startFlightPolling(hex, p); } catch (e) {}
                                    // Give the squawk API a short moment to populate and update tooltip when available
                                    (async () => {
                                        try {
                                            const sq = await fetchSquawkWithWait(hex, 1000, 200);
                                            if (sq) {
                                                try {
                                                    p.sqk = p.sqk || sq;
                                                    p.squawk = p.squawk || sq;
                                                    lastSquawk.set(hex, sq);
                                                    if (marker && marker._posData) {
                                                        marker._posData.sqk = marker._posData.sqk || sq;
                                                        marker._posData.squawk = marker._posData.squawk || sq;
                                                        const newHtml = buildHoverTooltipHTML(marker._posData);
                                                        try { const tt = marker.getTooltip && marker.getTooltip(); if (tt && tt.setContent) tt.setContent(newHtml); } catch (e) {}
                                                        try { const pp = marker.getPopup && marker.getPopup(); if (pp && pp.setContent) pp.setContent(newHtml); } catch (e) {}
                                                    }
                                                } catch (e) {}
                                            }
                                        } catch (e) {}
                                    })();
                                } catch (err) {
                                    console.warn('Debounced hover error for', hex, err);
                                }
                            }, HOVER_DEBOUNCE_MS);
                        } catch (err) {
                            console.warn('Hover handler (debounce) error for', hex, err);
                            setTrackStatus('Error', 'error');
                        }
                    });

                    marker.on('mouseout', () => {
                        // Cancel any pending hover fetch
                        if (hoverFetchTimer) { clearTimeout(hoverFetchTimer); hoverFetchTimer = null; }
                        // Delay clearing the hover track slightly to avoid flicker when moving between markers
                        if (hoverClearTimer) clearTimeout(hoverClearTimer);
                        hoverClearTimer = setTimeout(() => {
                            hoverTrackHex = null;
                            try { updateDebugPanel(null); } catch (e) {}
                            trackLayer.clearLayers();
                            if (map.hasLayer(trackLayer)) map.removeLayer(trackLayer);
                            // Stop per-aircraft flight polling when hover ends
                            try { stopFlightPolling(hex); } catch (e) {}
                        }, HOVER_CLEAR_MS);
                    });

                    // Click to persist (if checkbox enabled) ‚Äî toggle persisted track for this hex
                    marker.on('click', async () => {
                        try {
                            if (!hex) return;
                            const persistEnabled = document.getElementById('persist-on-click') ? document.getElementById('persist-on-click').checked : false;
                            // New behavior: if persist-on-click is OFF, show a temporary track for a short TTL.
                            if (!persistEnabled) {
                                setTrackStatus('Fetching (temp)...', 'loading');
                                const minutesElem = document.getElementById('track-window-input');
                                const minutes = minutesElem ? parseInt(minutesElem.value, 10) || 1 : 1;
                                try {
                                    const { points } = await fetchTrackWithCache(hex, minutes);
                                    if (points.length > 0) {
                                        // draw on tempPersistentLayer (distinct style)
                                        const latlngs = densifyTrackPoints(points, 0.1);
                                        const poly = L.polyline(latlngs, { color: '#ffaa00', weight: 3, opacity: 0.9, dashArray: '6,4', pane: 'persistentPane', interactive: false });
                                        const start = L.circleMarker(latlngs[0], { radius: 3, fillColor: '#00ff00', color: '#006600', weight: 1, fillOpacity: 0.9, pane: 'persistentPane' });
                                        const end = L.circleMarker(latlngs[latlngs.length - 1], { radius: 3, fillColor: '#ff0000', color: '#660000', weight: 1, fillOpacity: 0.9, pane: 'persistentPane' });
                                        const lg = L.layerGroup([poly, start, end]);
                                        tempPersistentLayer.addLayer(lg);
                                        if (!map.hasLayer(tempPersistentLayer)) tempPersistentLayer.addTo(map);
                                        setTrackStatus(formatOkWithTime(`Temp (${points.length})`), 'ok');
                                        // auto-remove after TTL
                                        setTimeout(() => {
                                            try { tempPersistentLayer.removeLayer(lg); } catch (e) {}
                                        }, TEMP_PERSIST_MS);
                                    } else {
                                        setTrackStatus('No data', 'error');
                                    }
                                } catch (err) {
                                    console.warn('Failed to fetch/show temp track for', hex, err);
                                    setTrackStatus('Error', 'error');
                                }
                                return;
                            }

                            // If persistEnabled is ON, proceed with toggle persisted behavior
                            // If already persisted, remove it
                            if (persistentTracks.has(hex)) {
                                const lg = persistentTracks.get(hex);
                                persistentTracksLayer.removeLayer(lg);
                                persistentTracks.delete(hex);
                                updatePersistedIndicator();
                                setTrackStatus(`Removed persisted ${hex}`, 'ok');
                                return;
                            }

                            setTrackStatus('Fetching...', 'loading');
                            const minutesElem = document.getElementById('track-window-input');
                            const minutes = minutesElem ? parseInt(minutesElem.value, 10) || 1 : 1;
                            try {
                                const { points } = await fetchTrackWithCache(hex, minutes);
                                if (points.length > 0) {
                                    const lg = L.layerGroup();

                                    // Create colored segments based on vertical rate
                                    const segments = [];
                                    let currentSegment = {
                                        points: [points[0]],
                                        color: getVerticalRateColor(points[0].vertical_rate || 0)
                                    };

                                    for (let i = 1; i < points.length; i++) {
                                        const point = points[i];
                                        const color = getVerticalRateColor(point.vertical_rate || 0);

                                        if (color === currentSegment.color) {
                                            // Continue current segment
                                            currentSegment.points.push(point);
                                        } else {
                                            // Start new segment
                                            segments.push(currentSegment);
                                            currentSegment = {
                                                points: [point],
                                                color: color
                                            };
                                        }
                                    }
                                    segments.push(currentSegment); // Add final segment

                                    // Draw each segment
                                    segments.forEach(segment => {
                                        if (segment.points.length >= 2) {
                                            const latlngs = densifyTrackPoints(segment.points, 0.1);
                                            const poly = L.polyline(latlngs, {
                                                color: segment.color,
                                                weight: 4,
                                                opacity: 0.95,
                                                pane: 'persistentPane',
                                                interactive: false
                                            });
                                            lg.addLayer(poly);
                                        }
                                    });

                                    // Add start/end markers
                                    const start = L.circleMarker([points[0].lat, points[0].lon], {
                                        radius: 4,
                                        fillColor: '#00ff00',
                                        color: '#006600',
                                        weight: 1,
                                        fillOpacity: 0.95,
                                        pane: 'persistentPane'
                                    });
                                    const end = L.circleMarker([points[points.length - 1].lat, points[points.length - 1].lon], {
                                        radius: 4,
                                        fillColor: '#ff0000',
                                        color: '#660000',
                                        weight: 1,
                                        fillOpacity: 0.95,
                                        pane: 'persistentPane'
                                    });
                                    lg.addLayer(start);
                                    lg.addLayer(end);

                                    persistentTracks.set(hex, lg);
                                    persistentTracksLayer.addLayer(lg);
                                    updatePersistedIndicator();
                                    try { updateDebugPanel(hex); } catch (e) {}
                                    setTrackStatus(formatOkWithTime(`Persisted (${points.length})`), 'ok');
                                } else {
                                    setTrackStatus('No data', 'error');
                                }
                            } catch (err) {
                                console.warn('Failed to fetch/persist track for', hex, err);
                                setTrackStatus('Error', 'error');
                            }
                        } catch (err) {
                            console.warn('Click handler error for', hex, err);
                        }
                    });

                    // Popup on click with more details (reuse tooltip html)
                    const popupHtml = buildHoverTooltipHTML(p);
                    marker.bindPopup(popupHtml);

                    // attach the live position object to marker for batch merges
                    marker._posData = p;

                    liveLayer.addLayer(marker);
                    liveMarkers.set(hex, marker);
                });

                // Remove any markers (and trails) that were not seen in this update
                [...liveMarkers.keys()].forEach(k => {
                    if (!seenHexes.has(k)) {
                        const m = liveMarkers.get(k);
                        try { liveLayer.removeLayer(m); if (map.hasLayer(m)) map.removeLayer(m); } catch (e) {}
                        liveMarkers.delete(k);
                        // Stop any flight polling associated with this marker
                        try { stopFlightPolling(k); } catch (e) {}
                        if (liveTrails.has(k)) {
                            const tr = liveTrails.get(k);
                            try { liveLayer.removeLayer(tr); if (map.hasLayer(tr)) map.removeLayer(tr); } catch (e) {}
                            liveTrails.delete(k);
                        }
                    }
                });

                // Ensure live layer is on the map
                if (!map.hasLayer(liveLayer)) liveLayer.addTo(map);
                setLiveStatus(formatOkWithTime(`OK (${positions.length})`), 'ok');
                // If long tracks toggle is enabled, ensure polling is active
                try {
                    const cb = document.getElementById('show-long-tracks');
                    if (cb && cb.checked) startLongTracksPolling();
                } catch (e) {}
            } catch (err) {
                console.warn('Failed to fetch live positions:', err);
                setLiveStatus('Error', 'error');
            }
        }

        function setLiveStatus(text, state) {
            const el = document.getElementById('live-fetch-status');
            if (!el) return;
            el.textContent = text;
            el.classList.remove('status-ok', 'status-loading', 'status-error');
            if (state === 'ok') el.classList.add('status-ok');
            else if (state === 'loading') el.classList.add('status-loading');
            else if (state === 'error') el.classList.add('status-error');
        }

        function setTrackStatus(text, state) {
            const el = document.getElementById('track-fetch-status');
            if (!el) return;
            el.textContent = text;
            el.classList.remove('status-ok', 'status-loading', 'status-error');
            if (state === 'ok') el.classList.add('status-ok');
            else if (state === 'loading') el.classList.add('status-loading');
            else if (state === 'error') el.classList.add('status-error');
        }

        // Helper that appends a local timestamp when state is OK
        function formatOkWithTime(baseText) {
            try {
                const now = new Date();
                return `${baseText} ‚Äî ${now.toLocaleTimeString()}`;
            } catch (e) {
                return baseText;
            }
        }

        function toggleLivePositions() {
            const enabled = document.getElementById('show-live').checked;
            if (enabled) {
                // Fetch immediately and then every 5 seconds
                fetchLivePositions();
                liveIntervalId = setInterval(fetchLivePositions, 5000);
                // Start batch polling for visible aircraft (rate-limited)
                try { startBatchPollingVisibleFlights(); } catch (e) { console.warn('Failed to start batch polling', e); }
                // Start live tracks polling to draw short recent tracks for active flights
                try { startLiveTracksPolling(); } catch (e) { console.warn('Failed to start live tracks polling', e); }
            } else {
                if (liveIntervalId) { clearInterval(liveIntervalId); liveIntervalId = null; }
                clearLiveLayer();
                // Clear any hovered track overlay
                hoverTrackHex = null;
                trackLayer.clearLayers();
                if (map.hasLayer(trackLayer)) map.removeLayer(trackLayer);
                // Stop batch polling when live is disabled
                try { stopBatchPollingVisibleFlights(); } catch (e) {}
                // Stop live tracks polling and clear live tracks
                try { stopLiveTracksPolling(); } catch (e) {}
            }
        }

        // Convert lat/lon distance to degrees (approximation)
        function nmToDegrees(nm) {
            // 1 degree latitude ‚âà 60 nm
            return nm / 60;
        }

        // Compute bearing from lat1,lon1 -> lat2,lon2 in degrees (0-360)
        function computeBearing(lat1, lon1, lat2, lon2) {
            try {
                const toRad = v => v * Math.PI / 180;
                const toDeg = v => v * 180 / Math.PI;
                const œÜ1 = toRad(lat1);
                const œÜ2 = toRad(lat2);
                const ŒîŒª = toRad(lon2 - lon1);
                const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
                const x = Math.cos(œÜ1) * Math.sin(œÜ2) - Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(ŒîŒª);
                let Œ∏ = Math.atan2(y, x);
                Œ∏ = toDeg(Œ∏);
                if (Œ∏ < 0) Œ∏ += 360;
                return Math.round(Œ∏);
            } catch (e) { return null; }
        }

        // Compute central angle (degrees) between two lat/lon points on a sphere
        function centralAngleDeg(lat1, lon1, lat2, lon2) {
            const toRad = v => v * Math.PI / 180;
            const œÜ1 = toRad(lat1);
            const œÜ2 = toRad(lat2);
            const ŒîœÜ = toRad(lat2 - lat1);
            const ŒîŒª = toRad(lon2 - lon1);
            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return c * 180 / Math.PI;
        }

        // Interpolate an intermediate point on the great-circle between two points
        // fraction in [0,1]
        function interpolateGreatCircle(lat1, lon1, lat2, lon2, f) {
            const toRad = v => v * Math.PI / 180;
            const toDeg = v => v * 180 / Math.PI;
            const œÜ1 = toRad(lat1), Œª1 = toRad(lon1);
            const œÜ2 = toRad(lat2), Œª2 = toRad(lon2);

            const sinœÜ1 = Math.sin(œÜ1), cosœÜ1 = Math.cos(œÜ1);
            const sinœÜ2 = Math.sin(œÜ2), cosœÜ2 = Math.cos(œÜ2);

            // angular distance
            const ŒîŒª = Œª2 - Œª1;
            const cosŒîŒª = Math.cos(ŒîŒª);
            const Œ¥ = Math.acos(Math.max(-1, Math.min(1, sinœÜ1 * sinœÜ2 + cosœÜ1 * cosœÜ2 * cosŒîŒª)));
            if (Œ¥ === 0) return [lat1, lon1];
            const sinŒ¥ = Math.sin(Œ¥);
            const A = Math.sin((1 - f) * Œ¥) / sinŒ¥;
            const B = Math.sin(f * Œ¥) / sinŒ¥;

            const x = A * cosœÜ1 * Math.cos(Œª1) + B * cosœÜ2 * Math.cos(Œª2);
            const y = A * cosœÜ1 * Math.sin(Œª1) + B * cosœÜ2 * Math.sin(Œª2);
            const z = A * sinœÜ1 + B * sinœÜ2;

            const œÜi = Math.atan2(z, Math.sqrt(x * x + y * y));
            const Œªi = Math.atan2(y, x);
            return [toDeg(œÜi), toDeg(Œªi)];
        }

        // Densify a track (array of {lat,lon,...}) by interpolating intermediate great-circle
        // points so each segment is at most `maxDeg` degrees of central angle.
        function densifyTrackPoints(points, maxDeg = 0.25) {
            if (!Array.isArray(points) || points.length < 2) return (points || []).map(p => [p.lat, p.lon]);
            const out = [];
            for (let i = 0; i < points.length - 1; i++) {
                const a = points[i];
                const b = points[i+1];
                if (!a || !b) continue;
                const lat1 = Number(a.lat), lon1 = Number(a.lon);
                const lat2 = Number(b.lat), lon2 = Number(b.lon);
                out.push([lat1, lon1]);
                const ang = centralAngleDeg(lat1, lon1, lat2, lon2);
                const steps = Math.max(1, Math.ceil(ang / maxDeg));
                // add intermediate points (exclude endpoints)
                for (let s = 1; s < steps; s++) {
                    const f = s / steps;
                    try {
                        const ip = interpolateGreatCircle(lat1, lon1, lat2, lon2, f);
                        out.push(ip);
                    } catch (e) {
                        // fallback: linear interpolation
                        const ilat = lat1 + (lat2 - lat1) * (s / steps);
                        const ilon = lon1 + (lon2 - lon1) * (s / steps);
                        out.push([ilat, ilon]);
                    }
                }
            }
            // push last point
            const last = points[points.length - 1];
            out.push([Number(last.lat), Number(last.lon)]);
            return out;
        }

        // Compute maximum angular change between consecutive course segments for a track
        // points: [{lat,lon,...}, ...] -> returns max delta in degrees
        function maxTrackAngularChange(points) {
            try {
                if (!Array.isArray(points) || points.length < 3) return 0;
                const bearings = [];
                for (let i = 0; i < points.length - 1; i++) {
                    const a = points[i];
                    const b = points[i+1];
                    if (a == null || b == null) { bearings.push(null); continue; }
                    const ba = computeBearing(a.lat, a.lon, b.lat, b.lon);
                    bearings.push(typeof ba === 'number' ? ba : null);
                }

                // (great-circle and densify helper functions are defined at top-level)
                let maxDelta = 0;
                for (let i = 0; i < bearings.length - 1; i++) {
                    const b1 = bearings[i];
                    const b2 = bearings[i+1];
                    if (b1 == null || b2 == null) continue;
                    // minimal angular difference
                    let diff = Math.abs(b2 - b1) % 360;
                    if (diff > 180) diff = 360 - diff;
                    if (diff > maxDelta) maxDelta = diff;
                }
                return maxDelta;
            } catch (e) { return 0; }
        }

        // Get color based on vertical rate (feet per minute)
        // Returns: 'red' for descending, 'green' for climbing, 'yellow' for level flight
        function getVerticalRateColor(verticalRate) {
            const rate = Math.abs(verticalRate || 0);

            // Thresholds for determining flight phase (feet per minute)
            const levelThreshold = 200;  // ¬±200 fpm considered level
            const climbThreshold = 500;  // >500 fpm climbing
            const descentThreshold = 500; // <-500 fpm descending

            if (verticalRate > climbThreshold) {
                return 'green';  // Climbing
            } else if (verticalRate < -descentThreshold) {
                return 'red';    // Descending
            } else {
                return 'yellow'; // Level flight
            }
        }

        // Get color based on intensity
        function getColorForIntensity(value, max, mode = 'intensity') {
            // Get scaling mode from UI
            const scalingModeElem = document.getElementById('scaling-mode');
            const scalingMode = scalingModeElem ? scalingModeElem.value : 'linear';
            let normalized = 0;
            if (scalingMode === 'log') {
                normalized = Math.log(value + 1) / Math.log(max + 1);
            } else if (scalingMode === 'sqrt') {
                normalized = Math.sqrt(value) / Math.sqrt(max);
            } else if (scalingMode === 'power') {
                normalized = Math.pow(value, 1/2.2) / Math.pow(max, 1/2.2);
            } else {
                normalized = value / max;
            }
            if (mode === 'intensity') {
                // Blue -> Green -> Yellow -> Red gradient
                if (normalized < 0.25) {
                    return `rgb(0, 0, ${Math.floor(255 * (normalized / 0.25))})`;
                } else if (normalized < 0.5) {
                    return `rgb(0, ${Math.floor(255 * ((normalized - 0.25) / 0.25))}, 255)`;
                } else if (normalized < 0.75) {
                    return `rgb(0, 255, ${Math.floor(255 * (1 - (normalized - 0.5) / 0.25))})`;
                } else {
                    return `rgb(${Math.floor(255 * ((normalized - 0.75) / 0.25))}, 255, 0)`;
                }
            } else if (mode === 'density') {
                // Red scale
                const red = Math.floor(255 * normalized);
                return `rgb(${red}, 0, 0)`;
            }
            return 'rgb(100, 100, 100)';
        }

        async function loadGridData() {
            try {
                showLoading(true);
                const timeWindow = document.getElementById('time-window').value;
                const startTime = Date.now();

                // Map UI window values to the backend hours parameter used by /api/heatmap-data
                function windowToHours(w) {
                    if (!w) return 24;
                    if (w === 'all') return 744; // default to ~31 days for "all"
                    if (w.endsWith('d')) {
                        const days = parseInt(w.replace('d',''), 10);
                        return isNaN(days) ? 24 : days * 24;
                    }
                    if (w.endsWith('h')) {
                        const hrs = parseInt(w.replace('h',''), 10);
                        return isNaN(hrs) ? 24 : hrs;
                    }
                    return 24;
                }

                const hours = windowToHours(timeWindow);
                const url = `/api/heatmap-data?hours=${hours}`;
                console.log(`Loading grid data with time window: ${timeWindow} -> ${hours} hours; fetching ${url}`);

                const response = await fetch(url);
                if (!response.ok) throw new Error(`API error: ${response.status}`);

                // Accept either an array response or an object { grid: [...] }
                const payload = await response.json();
                const gridData = Array.isArray(payload) ? payload : (payload.grid || []);
                const loadTime = Date.now() - startTime;
                console.log(`Received ${gridData.length} grid cells from API`);

                let totalPositions = 0;
                let minLat = Infinity, maxLat = -Infinity;
                let minLon = Infinity, maxLon = -Infinity;
                let maxCount = 0;

                gridData.forEach(cell => {
                    if (cell.count > 0) {
                        totalPositions += cell.count;
                        maxCount = Math.max(maxCount, cell.count);
                        minLat = Math.min(minLat, cell.lat_min);
                        maxLat = Math.max(maxLat, cell.lat_max);
                        minLon = Math.min(minLon, cell.lon_min);
                        maxLon = Math.max(maxLon, cell.lon_max);
                    }
                });

                currentData = {
                    gridCells: gridData,
                    totalPositions,
                    maxCount,
                    bounds: { minLat, maxLat, minLon, maxLon }
                };

                console.log(`Total positions calculated: ${totalPositions}, Max count: ${maxCount}, Cells with data: ${gridData.filter(c => c.count > 0).length}`);

                // Update grid display
                updateGridDisplay();

                // Update info panel
                document.getElementById('cell-count').textContent = gridData.filter(c => c.count > 0).length;
                document.getElementById('point-count').textContent = totalPositions.toLocaleString();
                document.getElementById('load-time').textContent = `${loadTime}ms`;
                document.getElementById('max-density').textContent = maxCount;
                
                const latSpan = (maxLat - minLat).toFixed(2);
                const lonSpan = (maxLon - minLon).toFixed(2);
                document.getElementById('coverage-area').textContent = 
                    `${latSpan}¬∞ √ó ${lonSpan}¬∞ (${gridData.filter(c => c.count > 0).length} cells)`;

                showLoading(false);

            } catch (error) {
                showLoading(false);
                showError(`Failed to load grid data: ${error.message}`);
            }
        }

        function updateGridDisplay() {
            if (!currentData || currentData.gridCells.length === 0) return;

            // Remove old layer
            if (gridLayer) map.removeLayer(gridLayer);

            const opacity = parseFloat(document.getElementById('opacity').value);
            const colorMode = document.getElementById('color-mode').value;
            const showBorders = document.getElementById('show-borders').checked;

            // Create feature group for all grid cells (placed into the dedicated heatmap pane)
            gridLayer = L.featureGroup([]);

            currentData.gridCells.forEach(cell => {
                if (cell.count === 0) return;

                // Create rectangle for 1nm x 1nm grid cell
                const bounds = [
                    [cell.lat_min, cell.lon_min],
                    [cell.lat_max, cell.lon_max]
                ];

                const color = getColorForIntensity(cell.count, currentData.maxCount, colorMode);

                const rectangle = L.rectangle(bounds, {
                    pane: 'heatmapPane',
                    color: showBorders ? '#333' : color,
                    weight: showBorders ? 1 : 0,
                    fillColor: color,
                    fillOpacity: opacity,
                    className: 'grid-cell'
                });

                // Add popup with cell info
                rectangle.bindPopup(`
                    <strong>Grid Cell</strong><br>
                    Lat: ${cell.lat_min.toFixed(4)}¬∞ to ${cell.lat_max.toFixed(4)}¬∞<br>
                    Lon: ${cell.lon_min.toFixed(4)}¬∞ to ${cell.lon_max.toFixed(4)}¬∞<br>
                    <strong>Positions: ${cell.count}</strong>
                `);

                gridLayer.addLayer(rectangle);
            });

            gridLayer.addTo(map);

            // Register heatmap overlay in the layers control so users can toggle it
            try { layersControl.addOverlay(gridLayer, 'Heatmap Grid'); } catch (e) {}

            // Ensure live positions and persisted tracks overlays are available in the control
            try { layersControl.addOverlay(liveLayer, 'Positions (Live)'); } catch (e) {}
            try { layersControl.addOverlay(persistentTracksLayer, 'Persisted Tracks'); } catch (e) {}
            try { layersControl.addOverlay(liveTracksLayer, 'Live Tracks'); } catch (e) {}

            // If the user has 'Show Live' checked, ensure live polling is started so tooltips populate
            try {
                const showLiveElem = document.getElementById('show-live');
                if (showLiveElem && showLiveElem.checked && !liveIntervalId) {
                    // Start live positions and batch polling
                    toggleLivePositions();
                }
            } catch (e) {
                console.warn('Auto-start live after grid load failed', e);
            }
            // Always do a one-time fetch of live positions so the positions overlay
            // is populated with the same data as the Live tab (tooltips/enrichment)
            try {
                fetchLivePositions();
            } catch (e) {
                console.warn('One-time fetch of live positions failed', e);
            }

            // Fit bounds to data
            if (currentData.bounds.minLat !== Infinity) {
                map.fitBounds([
                    [currentData.bounds.minLat, currentData.bounds.minLon],
                    [currentData.bounds.maxLat, currentData.bounds.maxLon]
                ]);
            }
        }

        function resetMap() {
            map.setView([39.5, -98.0], 4);
        }

        function toggleLegend() {
            const legend = document.getElementById('legend');
            legend.style.display = legend.style.display === 'none' ? 'block' : 'none';
        }

        // Load initial data
        loadGridData();
        // Load airline mapping for logo lookup
        loadAirlineMapping();
    </script>
</body>
</html>
